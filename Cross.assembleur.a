	PRINT	PUSH,OFF				INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'Cross.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'PrEqu.a'	INCLUDE	'PrintTrapsEqu.a'	; pour utiliser le printing manager	PRINT	POP				IMPORT	QD:QDGlobals	IMPORT	G:AppGlobals		* ==============================================* cross-assembleur pour microprocesseur 6305* ==============================================* structure de pile			StackCrossAssemble	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointMPU			ds.l	1Flags		ds.l	1StackCrossAssembleParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkProgramCounter	ds.l	1buffer		ds.b	256buffer2		ds.b	256	buffer3		ds.b	256	buffer4		ds.b	256FileBuffer	ds.l	1	; adresse du buffer fichierfinTexte	ds.l	1	; pointeur de fin du fichierRamStart	ds.l	1	; adresse de la ram pour assemblerZone		ds.l	1	; type de zone lue (étiquette, mnémonique…)currentline	ds.l	1	; n° de la ligne couranteerrorZone	ds.l	1	; pointeur de la zone d'erreuretiquetZone	ds.l	1	; pointeur de la zone d'étiquetteerrors		ds.l	1	; nombre d'erreurs dans l'assemblageSavePC		ds.l	1	; sauvegarde du pcItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectdialogStorage	ds	dWindlentotalLines		ds.w	1			; nombreTotalDelignelastPos			ds.w	1	; position du bar graphrectangle		ds	rectEtiqptr			ds.l	1etiqNum			ds.w	1StackCrossAssembleLocalSize	EQU 	*			; size of all the local variables			ENDR* variables : CrossAssemble	proc export		import	DoAssemble,ErrorInListing,WaitChar,DoDirective,Show_cursor,\				SetEtiquetteValue,GetEtiquetteValue,AddEtiquette,RotateCursor		WITH	StackCrossAssemble 	; cover our local stack frame		LINK	A6,#StackCrossAssembleLocalSize		; allocate our local stack frame		movem.l	d1-d7/a1-a4,-(sp)		move.l	filebuffer(a6),a0		move.l	#'ETIQ',d0		move.l	d0,zone(a6)		move.l	G.EtiquetteZone,a2	;raz liste étiquette		move.l	#0,(a2)		move.l	#0,programCounter(a6)		move.l	#1,currentline(a6)* Ouverture et Lecture du fichier source assembleur; en fait on le récupère du listingTE		clr.l	-(sp)		move.l	G.ListingTe,-(sp)		_TeGetText		move.l	(sp)+,a0		move.l	(a0),FileBuffer(a6)		; textptr=*Charhandle		move.l	G.ListingTe,a0		move.l	(a0),a3		;tePtr=*teHandle		moveq	#0,d0		move.w	teLength(a3),d0		; longueur du texte		and.l	#$ffff,d0		add.l	FileBuffer(a6),d0		move.l	d0,finTexte(a6);		move.l	G.ListingTe,a0		move.l	(a0),a0		; handle		move.w	TeNLines(a0),TotalLines(a6)				; on ouvre un dialog pour indiquer l'état de l'assemblage 138				clr.l	-(sp)		move.w	#138,-(sp)		pea		DialogStorage(a6)		move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog		pea		DialogStorage(a6)		_SetPort		* passage ‘PASS1’ lecture du fichier et fabrication de la liste d’étiquette		pea		DialogStorage(a6)		move.w	#1,-(sp)	; item 1 		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		#'PASSE 1'		_SetItext		_pennormal				pea		DialogStorage(a6)		move.w	#2,-(sp)	; item 1 		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	left+itemRect(a6),d0		add.w	#2,d0		move.w	d0,lastPos(a6)				pea		itemRect(a6)		_FrameRect		pea		QD.Gray		_PenPat PASS1				move.l	filebuffer(a6),a4		PASS1_Loop		; on rafraichie les status				bsr		DrawStatusBar				move.l	#32,-(sp)		jsr		RotateCursor		move.l	#'ETIQ',zone(a6)		move.b	(a4)+,d0		clr.l	buffer(a6)		; raz du buffer étiquette; on regarde si nous sommes sur une étiquette		cmp.b		#$3b,d0		beq		FinLigne_Passe1_Loop		; commentaire donc voir fin de ligne			cmp.b		#$2a,d0		beq		FinLigne_Passe1_Loop			cmp.b	#$0d,d0		beq.S	Ligne_FiniPasse1; on regarde si nous lisons actuellement une étiquette		cmp.b		#$41,d0		blo		PasEtiquette				; nous sommes sur une étiquette on place le texte dans un buffer tampon		lea.l		buffer(a6),a0			moveq		#0,d7			RecopieEtiquette_Loop		move.b		-1(a4,d7),d0		cmp.b		#$21,d0			; si char < espace => plus de caractères utiles		blo.s		FinLigne		; nous sommes à la fin de la ligne/texte		move.b		d0,1(a0,d7.w)		addq.w		#1,d7		cmp.w		#255,d7		blo.s		RecopieEtiquette_LoopFinLigne		move.b		d7,(a0)		and.l		#$ffff,d7		; extension word => longWord		add.l		d7,a4			; a4 pointe sur le prochain caractère ; après l’étiquette	; on regarde si cette étiquette éxiste déja dans la liste		lea			buffer(a6),a0		bsr			GetEtiquetteValue		tst.l		d1					; erreur donc elle n'existe pas		bne.s		NouvelleEtiquette		; oui elle existe donc erreur (double définition )		lea			Buffer(a6),a0		move.l		currentline(a6),d0		move.l		#-10,d1					; duplicate label "label" in line ##		bsr			ErrorInListing				bra			ZoneMnemonic_Pass1				; elle n'existe pas, on en créer une autreNouvelleEtiquette		lea			Buffer(a6),a0		moveq		#0,d0				; 0 par défaut		move.l		#-1,d1				; pas de valeur attribuée		bsr			AddEtiquette		; nouvelle étiquette; on change de zone		ZoneMnemonic_Pass1PasEtiquette		move.l	#'MNEM',zone(a6)		; zone mnémonique				bsr		WaitChar				; on attend la prochaine lettre		cmp.b	#$0d,(a4)				; fin de ligne ?		bne.s	No_endOfLine_Passe_1	; non; la ligne est fini, on passe à la suivante		;		adda.l	#00000001,a4Ligne_FiniPasse1		add.l	#1,currentline(a6)			; nouvelle ligne		bra		PASS1_Loop				; on reboucleNo_endOfLine_Passe_1		;	on regarde si c'est une directive, si oui on regarde si l'on peut l'exécuter		move.l	a4,a0					; pointeur de la ligne		lea		buffer(a6),a1			; au cas ou:  "étiquette dc.b	'jhvgkjhgj'"		bsr		DoDirective		cmp.l	#-100,d1				; pas une directive erreur		beq.s	NotADirective_Passe1					cmp.l	#-101,d1					; directive "end" fin de fichier		beq		Start_Passe2			; on passe à la passe 2		cmp.l	#0,d1					; autre erreur		beq		FinLigne_Passe1				move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1		; pas d'erreurNotADirective_Passe1FinLigne_Passe1FinLigne_Passe1_Loop; on attend la fin de la ligne		move.b	(a4)+,d0		beq.s	Start_Passe2			; 0 pour fin de fichier ( pas de end)		cmp.l	finTexte(a6),a4		bhi.s	Start_Passe2			; fin du fichier (pas de end)		cmp.b	#$0d,d0		bne.s	FinLigne_Passe1_Loop		add.l	#1,currentline(a6)			; nouvelle ligne		bra		PASS1_Loop				; on reboucle; -------------------------------------------------------------------; PASSE 2; génération du codeStart_Passe2		pea		DialogStorage(a6)		move.w	#1,-(sp)	; item 1 		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		#'PASSE 2'		_SetItext		_pennormal				pea		DialogStorage(a6)		move.w	#2,-(sp)	; item 1 		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.w	left+itemRect(a6),d0		add.w	#2,d0		move.w	d0,lastPos(a6)		_PenNormal				move.l	G.RomImage,a3				move.l	filebuffer(a6),a4		clr.l	programCounter(a6)		; on part au début		move.l	#1,currentline(a6)		PASS2_Loop		bsr		DrawStatusBar		move.l	#32,-(sp)		jsr		RotateCursor		move.l	#'ETIQ',zone(a6)		move.b	(a4)+,d0; on regarde si nous sommes sur une étiquette		clr.w		buffer(a6)		; raz étiquette			cmp.b		#$3b,d0		beq			FinLigne_Passe2_Loop				cmp.b		#$2a,d0		beq			FinLigne_Passe2_Loop		cmp.b		#$0d,d0		beq 		Ligne_FiniPasse2; on regarde si nous lisons actuellement une étiquette		moveq		#0,d7		cmp.b		#$41,d0		blo			DirectivePasse2		; pas une étiquette		; nous sommes sur une étiquette on place le texte dans un buffer tampon		lea.l		buffer(a6),a0			RecopieEtiquette_Loop_Passe2		move.b		-1(a4,d7),d0		cmp.b		#$21,d0			; si char < espace => plus de caractères utiles		blo.s		FinLigne_passe2		; nous sommes à la fin de la ligne/texte		cmp.b		#$3a,d0				; genre TOTO:		beq.s		FinLigne_passe2		; nous sommes à la fin de la ligne/texte		move.b		d0,1(a0,d7.w)		addq.w		#1,d7		cmp.w		#255,d7		blo.s		RecopieEtiquette_Loop_passe2FinLigne_Passe2	; et de l'étiquette		move.b		d7,(a0)		and.l		#$ffff,d7		; extension word => longWord		add.l		d7,a4			; a4 pointe sur le prochain caractère ; après l’étiquette; on regarde maintenant s'il y a une directive après; si directive equ d1=' EQU' dans ce cas on n'affecte pas le compteur ordinal à l'étiquette; dans le cas contraire le pc courant est affecté à l'étiquette; sauvegarde du pc courant		move.l	ProgramCounter(a6),savePC(a6)DirectivePasse2	; on attend le prochain caractère		bsr			WaitChar				cmp.b		#$0d,(a4)				; fin de ligne ?		beq 		Ligne_FiniPasse2_etiq		; oui				move.l		a4,a0		bsr			DoDirective; résultat dans d1		cmp.l		#' EQU',d1		beq 		FinLigne_Passe2_Loop	; c'était une directive d'assignation		cmp.l		#-100,d1				; pas une directive erreur		beq 		Assemble_Passe2					cmp.l		#-101,d1				; directive "end" fin de fichier		beq			FinPasse2				; on a fini l'assemblage		cmp.l		#10000,d1				; valeur déjà dans l'étiquette		beq.s		DirectiveOK_Passe2		; oui		cmp.l		#0,d1					; pas étiquette		beq.s		DirectiveOK_Passe2; autre erreur				move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1		bra			FinLigne_Passe2_Loop; -DirectiveOK_Passe2; on regarde s'il y a une étiquette					tst.b		Buffer(a6)		beq 		FinLigne_Passe2_Loop		move.l		SavePC(a6),d0		lea			Buffer(a6),a0		bsr			SetEtiquetteValue		cmp.l		#10000,d1	; valeur déjà dans l'étiquette		beq 		FinLigne_Passe2_Loop		tst.l		d1		beq 		Start_Passe2		; l'étiquette est modififiée , on repart au début				move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1		bra			FinLigne_Passe2_Loop; --------------------------------------------; on regarde s'il faut affecter une valeur à l'étiquette avant de passer à la ligne suivante		Ligne_FiniPasse2_etiq		tst.b		Buffer(a6)		beq 		Ligne_FiniPasse2				move.l		SavePC(a6),d0		lea			Buffer(a6),a0		bsr			SetEtiquetteValue		cmp.l		#10000,d1	; valeur déjà dans l'étiquette		beq 		Ligne_FiniPasse2		tst.l		d1		beq 		Start_Passe2		; l'étiquette est modififiée , on repart au début				move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1		bra			Ligne_FiniPasse2; -----------------------Assemble_Passe2		; on regarde s'il y a une étiquette à modifier				tst.b		Buffer(a6)		beq.s		Assemble_Passe2_1						move.l		SavePC(a6),d0		lea			Buffer(a6),a0		bsr			SetEtiquetteValue		cmp.l		#10000,d1				; valeur déjà dans l'étiquette		beq.s		Assemble_Passe2_1	; on ne change rien mais, on passe regarde s'il y a une instruction		tst.l		d1		beq.s		Start_Passe2	; l'étiquette est modififiée , on repart au début				move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1; ------Assemble_Passe2_1			move.l		a4,a0		bsr			DoAssemble		tst.l		d1		beq 		FinLigne_Passe2_Loop; erreur dans assemblage		move.l		currentline(a6),d0	;  "error name" in line ##		bsr			ErrorInListing		;  error code in d1FinLigne_Passe2_Loop; on attend la fin de la ligne		move.b	(a4)+,d0		cmp.b	#0,d0		beq.s	FinPasse2				; 0 pour fin de fichier ( pas de end)		cmp.l	finTexte(a6),a4		bhi.s	FinPasse2				; fin du fichier (pas de end)		cmp.b	#$0d,d0		bne.s	FinLigne_Passe2_LoopLigne_FiniPasse2		add.l	#1,currentline(a6)			; nouvelle ligne		bra		PASS2_Loop				; on reboucle; --------------------------------------------------------; nous avons fini d'assembler le programmeFinPasse2; on regarde s'il y a des erreurs dans le fichier		tst.l	errors(a6)		beq		NoError		NoError	pea	QD.Arrow		_SetCursor		_ShowCursor		pea		DialogStorage(a6)		_CloseDialog		movem.l	(sp)+,d1-d7/a1-a4						UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#StackCrossAssembleParamSize,SP		; strip all of the caller's parameters		JMP	(A0)DrawStatusBar		move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0	; largeur reglette		sub.w	#8,d0		mulu	2+currentline(a6),d0		divu	totalLines(a6),d0		cmp.w	lastpos(a6),d0		add.w	left+itemRect(a6),d0		add.w	#2,d0		bne.s	RefreshBar		rtsRefreshBar		move.L	itemRect(a6),rectangle(a6)		move.L	4+itemRect(a6),4+rectangle(a6)		move.w	lastpos(a6),left+rectangle(a6)		move.w	d0,lastpos(a6)		move.w	d0,right+rectangle(a6)		add.w	#2,top+rectangle(a6)		sub.w	#2,bottom+rectangle(a6)		pea		rectangle(a6)		_paintRect		rts		DbgInfo.New	CrossAssemble		endP* ---------------------------* sous-programmes* ---------------------------* =======================================* DoAssemble	* =======================================; cette routine génère le code machine correspondannt à l'instruction; pointée par a0; à l'adresse pointée par ProgramCounter(a6)DoAssemble	proc export			import	ErrorInListing,WaitChar,WaitChar_Special,findNextArgument,\				SetEtiquetteValue,GetEtiquetteValue,AddEtiquette,GetIndString,CmpStr		WITH	StackCrossAssemble 	; cover our local stack frame							; le stack frame de cross assemble							; d'ou le manque de link #stackframe,a6 ...									movem.l	d2-d7/a1-a3,-(sp); on recopie la Mnemonic dans un buffer pour comparaison		moveq	#0,d7		lea		buffer2(a6),a1RecopieMnemonic_Loop		move.b	(a0,d7.w),d0; on regarde si c'est un séparateur				cmp.b	#';',d0		beq.s	FinRecopieMnemonic		cmp.b	#'*',d0		beq.s	FinRecopieMnemonic		cmp.b	#',',d0		beq.s	FinRecopieMnemonic		cmp.b	#':',d0		beq.s	FinRecopieMnemonic		cmp.b	#'#',d0		beq.s	FinRecopieMnemonic		cmp.b	#'$',d0		beq.s	FinRecopieMnemonic				cmp.b	#'%',d0		beq.s	FinRecopieMnemonic		cmp.b	#$3a,d0		blo.s	FinRecopieMnemonic		move.b	d0,1(a1,d7.w)		addq.W	#1,d7		bra.s	RecopieMnemonic_LoopFinRecopieMnemonic		move.b	d7,(a1)		add.l	d7,a0	; (a0)=char suivant l'étiquette		move.l	a0,a3	; sauvegarde futur pc; on regarde qu'elle est la Mnemonic						move.l	#1,d7	; 1 ère mnémonique		FindMnemonique_Loop				pea		Buffer3(a6)		move.w	#129,-(sp)		move.w	d7,-(sp)			jsr		GetIndString				tst.b	Buffer3(a6)				; une chaine en retour ?		beq		ErrorNotKnownMnemonic	; non donc erreur				lea		buffer3(a6),a0		lea		buffer2(a6),a1				bsr		CmpStr		tst.w	d0		beq.s	FoundMnemonic; ce n'est pas la mnémonique on passe à la suivante				addq.w	#1,d7		bra.s	FindMnemonique_Loop		; mnémonique inconnue donc erreur		ErrorNotKnownMnemonic		move.l	#-10000,d1			bra	Exit		FoundMnemonic; on recherche	l'op code de base de la mnémonique					move.l	G.ResourceDATA129,a0			move.l	(a0),a0					; handle			move.b	-1(a0,d7.w),d6			; op code in d6			lea		buffer2(a6),a1; on dispatch le calcul de l'op code en fct du n°			move.l	a3,a4			cmp.w	#1,d7			beq		Ligne01		; brset			cmp.w	#2,d7			beq		Ligne02		; brclr			cmp.w	#3,d7			beq		Ligne03		; bset			cmp.w	#4,d7			beq		Ligne04		; bclr						cmp.w	#21,d7			blo		Ligne20		; branch instructions (relative)						cmp.w	#33,d7			blo		Ligne30		; read/modify/write 			cmp.w	#47,d7			blo		ligne90		; implied (one byte instruction)			cmp.w	#60,d7			beq		ligne20		; bsr (relative); ligne Ax => Fx		register/memory (instruction)						bra		ligneA0			; brset/brClr	instructions		Ligne01			; brset		jsr	getBitNum		cmp.l	#-1,d0;		beq 	UnKnownInstruction;		on calcule l'opcode de l'instruction		lsl.b	#1,d0	; *2		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra		ligne2_Argument; --		Ligne02			; brclr			jsr	getBitNum		cmp.l	#-1,d0;		beq 	UnKnownInstruction;		on calcule l'opcode de l'instruction		lsl.b	#1,d0	; *2		add.b	#1,d0		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)		ligne2_Argument	; on s'occupe de récupérer les paramètres suivants; adresse (directe)			bsr		WaitChar		move.l	a4,a0		bsr		findNextArgument		tst.l	d1;		bne 	ErreurOperande			move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)		move.b	(a4)+,d0				; on avance d'un caractère; offset sur le 		move.l	a4,a0		bsr		findNextArgument		tst.l	d1;		bne 	ErreurOperande			move.l	ProgramCounter(a6),d1		addq.l	#1,d1		sub.l	d1,d0		cmp.l	#-127,d0;		blt		ErreurDeplacementTropLarge		cmp.l	#255,d0;		bhi		ErreurDeplacementTropLarge				move.l	G.RomImage,a1		move.b	d0,-1(a1,d1)		add.l	#1,ProgramCounter(a6)		bra	Exit		; ------------------------		; bset/bclr	instructions				Ligne03					jsr	getBitNum		cmp.l	#-1,d0;		beq 	UnKnownInstruction;		on calcule l'opcode de l'instruction		lsl.b	#1,d0	; *2		add.b	#$10,d0		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)				bra	ligne4_Calc; --Ligne04				jsr		getBitNum		cmp.l	#-1,d0;		beq 	UnKnownInstruction;on calcule l'opcode de l'instruction		lsl.b	#1,d0	; *2		add.b	#$11,d0		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)ligne4_Calc		bsr		WaitChar		move.l	a4,a0		bsr		findNextArgument		tst.l	d1;		bne 	ErreurOperande			move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra	Exit		; ------------------------; instruction de branchement relativeLigne20			move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d6,(a1,d1)		add.l	#1,ProgramCounter(a6)				bsr		WaitChar		move.l	a4,a0				bsr		findNextArgument		tst.l	d1;		bne 	ErreurOperande			move.l	ProgramCounter(a6),d1		addq.l	#1,d1		sub.l	d1,d0		cmp.l	#-127,d0;		blt		ErreurDeplacementTropLarge		cmp.l	#255,d0;		bhi		ErreurDeplacementTropLarge				move.l	G.RomImage,a1		move.b	d0,-1(a1,d1)		add.l	#1,ProgramCounter(a6)		bra	Exit; -----------------------; instruction en 1 octetsLigne90			move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d6,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra		Exit; ------------------------; instruction de modification mémoire registresLigne30; on détermine quelle mode d'adressage est en cour		bsr		WaitChar_Special		move.b	(a4),d0		cmp.b	#'A',d0		beq.s	ImpiedA_1		cmp.b	#'a',d0		beq.s	ImpiedA_1		cmp.b	#'X',d0		beq.s	ImpiedX_1		cmp.b	#'x',d0		beq.s	ImpiedX_1		bra		NotImplied; ---------		; ON Regarde si c'est un a unique ; si oui implied a; si non peu ètre étiquetteImpiedA_1		move.b	1(a4),d0		cmp.b	#' ',d0		beq 	ImpiedA		cmp.b	#0,d0		beq 	ImpiedA		cmp.b	#$d,d0		beq 	ImpiedA		cmp.b	#9,d0		beq  	ImpiedA		beq.s	NotImplied; ---------; ON Regarde si c'est un a unique ; si oui implied a; si non peu ètre étiquette				ImpiedX_1		move.b	1(a4),d0		cmp.b	#' ',d0		beq 	ImpiedX		cmp.b	#0,d0		beq 	ImpiedX		cmp.b	#$d,d0		beq		ImpiedX		cmp.b	#9,d0		beq		ImpiedX		NotImplied		; ce n'est pas un mode implied a ou x		cmp.b	#',',d0		bne.s	NotX0_ligne30		move.b	(a4)+,d0		move.b	(a4)+,d0		cmp.b	#'X',d0		beq.s	Indexed0_ligne30		cmp.b	#'x',d0		beq.s	Indexed0_ligne30;		bra.s	ErrorOperandeNotX0_ligne30		move.l	a4,a0		bsr		findNextArgument		tst.l	d1;		beq.s	ErrorOperande		cmp.l	#255,d0;		bhi		ErreurDeplacementTropLarge				move.b	(a4)+,d3		cmp.b	#',',d3;		bne.s	ErrorOperande		move.b	(a4)+,d3		and.b	#$df,d3		cmp.b	#'x',d3;		bne.s	ErrorOperande	; -------; mode direct		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d6,(a1,d1)		add.l	#1,ProgramCounter(a6)		; on place l'offset dans le mémoire				move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra		Exit;--------; mode inhérent à l'accumulateur a ImpiedA		add.b	#$10,d6		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d6,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra		Exit;--------; mode inhérent au registre   X ImpiedX		add.b	#$20,d6		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d6,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra		Exit;--------Indexed0_ligne30		add.b	#$40,d6		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d6,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra	Exit; ------------------------; instruction de calcul des registres// mémoireLigneA0			; on recherche le mode d'adressage			bsr		WaitChar_Special			cmp.b	#',',(a4)			bne.s	PasNoOffset			move.b	(a4)+,d3			move.b	(a4)+,d3			and.b	#$df ,d3			cmp.b	#'X',d3			beq.S	indexe_0;			bra.s	error		mode adressage inconnuPasNoOffset						move.l	a4,a0			bsr		findNextArgument			tst.l	d1;			beq.s	ErrorOperande			btst 	#15,d2			bne		Immediat; on regarde si mode 8 ou 16 bits			cmp.l	#255,d0			bhi.s	Sup8bits; data sur 8 bits; on regarde si mode indéxé ou non 			move.b	(a4),d3						cmp.b	#',',d3			bne.s	Direct			bra.s	indexe_8bits; --				Sup8bits			move.b	(a4),d3					cmp.b	#',',d3			bne 	EtenduMode                                   			bra.s	indexe_16bits; -------------indexe_0			add.b	#$50,d6			move.l	G.RomImage,a1			move.l	ProgramCounter(a6),d1			move.b	d6,(a1,d1.w)			add.l	#1,ProgramCounter(a6)						bra Exit; -------------indexe_8bits			add.b	#$40,d6			move.l	G.RomImage,a1			move.l	ProgramCounter(a6),d1			move.b	d6,(a1,d1)			add.l	#1,ProgramCounter(a6)									move.l	ProgramCounter(a6),d1			move.b	d0,(a1,d1.w)			add.l	#1,ProgramCounter(a6)			bra	Exit; -------------Indexe_16bits						add.b	#$30,d6			move.l	G.RomImage,a1			move.l	ProgramCounter(a6),d1			move.b	d6,(a1,d1)			add.l	#1,ProgramCounter(a6)						move.w	d0,d2			lsr.w	#8,d2; poid fort						move.l	ProgramCounter(a6),d1			move.b	d2,(a1,d1.w)			add.l	#1,ProgramCounter(a6)			; poid faible										move.l	ProgramCounter(a6),d1			move.b	d0,(a1,d1.w)			add.l	#1,ProgramCounter(a6)									bra	Exit; -------------Direct			add.b	#$10,d6			move.l	G.RomImage,a1			move.l	ProgramCounter(a6),d1			move.b	d6,(a1,d1)			add.l	#1,ProgramCounter(a6)						move.l	ProgramCounter(a6),d1			move.b	d0,(a1,d1.w)			add.l	#1,ProgramCounter(a6)			bra	Exit; -------------Immediat			move.l	G.RomImage,a1			move.l	ProgramCounter(a6),d1			move.b	d6,(a1,d1)			add.l	#1,ProgramCounter(a6)						move.l	ProgramCounter(a6),d1			move.b	d0,(a1,d1.w)			add.l	#1,ProgramCounter(a6)						bra	Exit; -------------EtenduMode						add.b	#$20,d6			move.l	G.RomImage,a1			move.l	ProgramCounter(a6),d1			move.b	d6,(a1,d1)			add.l	#1,ProgramCounter(a6)									move.w	d0,d2			lsr.w	#8,d2; poid fort						move.l	ProgramCounter(a6),d1			move.b	d2,(a1,d1.w)			add.l	#1,ProgramCounter(a6)			; poid faible										move.l	ProgramCounter(a6),d1			move.b	d0,(a1,d1.w)			add.l	#1,ProgramCounter(a6)						; ------			exit		movem.l	(sp)+,d2-d7/a1-a3 			rts									* ------------------------------------------- *						getBitNum			moveq 	#0,d0			move.b	(a3)+,d0	; n° du byte			sub.b	#$30,d0			blt.s	SyntaxError_bitNum			cmp.b	#9,d0			bhi.s	Alfa			rtsalfa		sub.b	#7,d0			cmp.b	#$f,d0			bhi.s	SyntaxError_bitNum			rts			SyntaxError_bitNum					move.l	#-1,d0			rts									DbgInfo.New		DoAssemble				STRING	PASCAL						endP* =======================================* =====================================*	DoDirective()* =====================================; cette routine effectue les directives pour l'assemblage;;;	entrée: a0 pointeur sur la chaîne de directive;			a1 sur la chaîne d'une étiquette placée devant sinon (a1).b =0;;	sortie: d1 code erreur:	-100 pas une directive; -101 directive end;						   	-199 <erreur<-101	 autres erreurs	;;;;	directives:;étiquette 		equ		value	; valeur dans étiquette  (définitif);étiquette 		=		value	; valeur dans étiquette  (définitif);étiquette 		set		value	; valeur dans étiquette  (momentanné);; n.b. : value $=héxa, =décimal;%=binaire;;				org		value 	; program counter= value;étiquette		dc.b	value,value,value,...	(value sur 8 bits);				dc.w	value,value,value,...	(value sur 16 bits);				dc.b	"texte	    (le texte s'arrète à la fin de la ligne en cour) ;				end fin de fichier d'assemblage;DoDirective	proc export		import	DoAssemble,ErrorInListing,WaitChar,findNextArgument,\				SetEtiquetteValue,GetEtiquetteValue,AddEtiquette,GetIndString,CmpStr		WITH	StackCrossAssemble 	; cover our local stack frame							; le stack frame de cross assemble							; d'ou le manque de link #stackframe,a6 ...									movem.l	d2-d7/a1-a3,-(sp); on recopie la directive dans un buffer pour comparaison		moveq	#0,d7		lea		buffer2(a6),a1RecopieDirective_Loop		move.b	(a0,d7.w),d0; on regarde si c'est un séparateur				cmp.b	#';',d0		beq.s	FinRecopieDirective		cmp.b	#'*',d0		beq.s	FinRecopieDirective		cmp.b	#',',d0		beq.s	FinRecopieDirective		cmp.b	#':',d0		beq.s	FinRecopieDirective		cmp.b	#'#',d0		beq.s	FinRecopieDirective		cmp.b	#'$',d0		beq.s	FinRecopieDirective				cmp.b	#'%',d0		beq.s	FinRecopieDirective		cmp.b	#$27,d0		beq.s	FinRecopieDirective		cmp.b	#$0e,d0		blo.s	FinRecopieDirective		cmp.b	#$20,d0		beq.s	FinRecopieDirective		bhi.s	RecopieDirective_Cont		adda.l	#1,a0						; on passe le caractère de contrôle ou l'espaceRecopieDirective_Cont			; non donc on le place dans le buffer				move.b	d0,1(a1,d7.w)		addq.W	#1,d7		bra.s	RecopieDirective_LoopFinRecopieDirective		move.b	d7,(a1)		add.l	d7,a0	; (a0)=char suivant l'étiquette		move.l	a0,a3	; sauvegarde futur pc; on regarde qu'elle est la directive;directive	"end"		pea		Buffer3(a6)		move.w	#128,-(sp)		move.w	#3,-(sp)	; END		jsr		GetIndString				lea		buffer3(a6),a0		lea		buffer2(a6),a1		bsr		CmpStr		tst.w	d0		bne.s	PasDirective_Enddirective_End		move.l	a3,a4	; on pointe sur la suite de la chaîne		move.l	#-101,d1	; code fin de fichier		bra		Exit		; --------		PasDirective_End						pea		Buffer3(a6)		move.w	#128,-(sp)		move.w	#6,-(sp)	; ORG		jsr		GetIndString				lea		buffer3(a6),a0		lea		buffer2(a6),a1		bsr		CmpStr		tst.w	d0		bne.s	PasDirective_ORGdirective_ORG				move.l	a3,a4	; on pointe sur la suite de la chaîne		move.l	a4,a0		bsr		findNextArgument		tst.l	d1		beq.s	ORG_PasErreurArgument; erreur argument				move.l	#-103,d1			ORG_PasErreurArgument				move.l	d0,programCounter(a6)				bra		Exit		; ------		PasDirective_ORG			pea		Buffer3(a6)		move.w	#128,-(sp)		move.w	#4,-(sp)	;=		jsr		GetIndString				lea		buffer3(a6),a0		lea		buffer2(a6),a1		bsr		CmpStr		tst.w	d0		beq.s	Directive_EQU; -		pea		Buffer3(a6)		move.w	#128,-(sp)		move.w	#5,-(sp)	; EQU		jsr		GetIndString				lea		buffer3(a6),a0		lea		buffer2(a6),a1		bsr		CmpStr		tst.w	d0		bne.s	PasDirective_EQUdirective_EQU				move.l	a3,a4	; on pointe sur la suite de la chaîne		move.l	a4,a0		bsr		findNextArgument		tst.l	d1		beq.s	PasErreurEQU				move.l	#-103,d1		bra 	Exit		PasErreurEQU		; on regarde s'il y a une étiquette dans le buffer		lea		buffer(a6),a0		move.l	#0,d1			; valeur fixée une fois pour toute		bsr		SetEtiquetteValue		cmp.l	#10000,d1		beq.s	@1		tst.l	d1		bne		Exit	; il y a erreur on garde le code erreur @1		move.l	#' EQU',d1		bra		Exit		; -------------		PasDirective_EQU		pea		Buffer3(a6)		move.w	#128,-(sp)		move.w	#7,-(sp)	; SET		jsr		GetIndString				lea		buffer3(a6),a0		lea		buffer2(a6),a1		bsr		CmpStr		tst.w	d0		bne.s	PasDirective_SETdirective_SET				move.l	a3,a4	; on pointe sur la suite de la chaîne		move.l	a4,a0		bsr		findNextArgument		tst.l	d1		beq.s	PasErreurSET				move.l	#-103,d1		bra 	Exit		PasErreurSET		; on regarde s'il y a une étiquette dans le buffer		lea		buffer(a6),a0		move.l	#80,d1		bsr		SetEtiquetteValue		cmp.l	#10000,d1		beq.s	@1		tst.l	d1		bne		Exit	; il y a erreur on garde le code erreur @1		move.l	#' EQU',d1		bra		Exit;--------------PasDirective_SET					pea		Buffer3(a6)		move.w	#128,-(sp)		move.w	#1,-(sp)	; DC.B		jsr		GetIndString				lea		buffer3(a6),a0		lea		buffer2(a6),a1		bsr		CmpStr		tst.w	d0		bne 	PasDirective_DCBdirective_DCB		move.l	a3,a4	; on pointe sur la suite de la chaîne		move.l	G.RomImage,a1		move.l	a4,a0;on regarde s'il y a le délimiteur ' dans le reste de la ligne	FindQuote_Loop		move.b	(a0)+,d0		cmp.b	#$0d,d0		beq.s	Findeligne_DCB2	; pas une ligne de texte		cmp.b	#'$',d0		beq.s	Findeligne_DCB2	; pas une ligne de texte		cmp.b	#'#',d0		beq.s	Findeligne_DCB2	; pas une ligne de texte		cmp.b	#'%',d0		beq.s	Findeligne_DCB2	; pas une ligne de texte		cmp.b	#$30,d0		blo.s	PasChiffre_DCB; un chiffre donc pas une ligne de texte		suba.l	#$00000001,a0		bra.s	Findeligne_DCB	; pas une ligne de texte; --		PasChiffre_DCB			cmp.b	#$27,d0			; ' pour délimiteur texte		bne.s	FindQuote_Loop		; c'est du texte, on le place dans la mémoireLoopRecopieTexte		move.b	(a0)+,d0		beq.s	finDcb		; fin du fichier		cmp.b	#$0d,d0		; fin de ligne de texte		beq.s	finDcb		cmp.b	#$27,d0		; fin du texte		bne.s	PasQuoteDeFin		move.b	(a0)+,d0		cmp.b	#$27,d0		bne.s	QuoteDeFin			bra.s	LoopRecopieTextePasQuoteDeFin			cmp.b	#$0d,d0		beq.S	finDcb		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)		bra.s	LoopRecopieTexte	; boucle tant q'il y a des caractères dans la ligne		Findeligne_DCB2		suba.l	#$0000001,a0QuoteDeFin	; on attend le déluge		cmp.b	#$0d,d0		beq.s	finDcbFindeligne_DCB				bsr		findNextArgument		tst.l	d1		bne 	Exit			move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.b	d0,(a1,d1)		add.l	#1,ProgramCounter(a6)		move.l	a4,a0		cmp.b	#$0d,(a4)		beq.s	finDcb		; fin de ligne rencontrée		cmp.b	#$00,(a4)		beq.s	finDcb		; fin de ligne rencontrée		bra.s	Findeligne_DCBfinDcb		clr.l	d1		bra		Exit;--------------PasDirective_DCB			pea		Buffer3(a6)		move.w	#128,-(sp)		move.w	#2,-(sp)	; DC.W		jsr		GetIndString				lea		buffer3(a6),a0		lea		buffer2(a6),a1		bsr		CmpStr		tst.w	d0		bne.s	PasDirective_DCWdirective_DCW				move.l	a3,a4	; on pointe sur la suite de la chaîne		move.l	a4,a0		Findeligne_DCW				bsr		findNextArgument		tst.l	d1		bne 	Exit		move.l	G.RomImage,a1		move.l	ProgramCounter(a6),d1		move.W	d0,(a1,d1)		add.l	#2,ProgramCounter(a6)				cmp.b	#$0d,(a4)		beq.s	finDcW		; fin de ligne rencontrée		cmp.b	#$00,(a4)		beq.s	finDcw		; fin de ligne rencontrée		move.l	a4,a0		bra.s	QuoteDeFinfinDcW		clr.l	d1		bra		Exit;--------------PasDirective_DCW	; ce n'est pas une directive, donc on place le code -100		move.l	#-100,d1	; code pas une directive					exit	movem.l	(sp)+,d2-d7/a1-a3						rts		DbgInfo.new		DoDirective		endP* ====================================================* findNextArgument()* ====================================================;; Recherche un argument à la suite de a0, une étiquette ou bien une valeur (tout format); retourne la valeur dans d0; code erreur dans d1: 0 pas d'erreur;						-1 étiquette non définie ;						-2 pas d'arguments;						-3 syntax error;					;	dans d2 on dispose des renseignements suivants:;;	b15=1			pour une chaîne commençant par #;	b14=1			pour un caractère alpha (commençant par ");	b13=1			pour une valeur héxa;	b12=1			pour une valeur binaire;	b11=1			pour le resultat en provenance d'une étiquette;   b0,b1=			0 pour une chaine de 2 caractères (<256)	;					1 pour une chaîne	de 2à 4 caractère (0< value<65536);					2 pour une chaine sup à 4 caractère;;;;findNextArgument proc export		import	DoAssemble,ErrorInListing,WaitChar,\				SetEtiquetteValue,GetEtiquetteValue,AddEtiquette,GetIndString,CmpStr		WITH	StackCrossAssemble 	; cover our local stack frame							; le stack frame de cross assemble							; d'ou le manque de link #stackframe,a6 ...				; on recherche le prochain caractèreLoop_AttendChar		move.b	(a0),d0		cmp.b	#',',d0			; si "," on passe char suivant		beq.s	charsuiv		cmp.b	#$09,d0			; si tab on passe char suivant		beq.s	charsuiv		cmp.b	#' ',d0		bne.s	FinAttendCharcharsuiv				adda.l	#1,a0		bra.s	Loop_AttendCharFinAttendChar; on recopie la suite dans un buffer				moveq	#0,d7		lea		buffer2(a6),a1RecopieArgument_Loop		move.b	(a0,d7.w),d0; on regarde si c'est un séparateur				cmp.b	#',',d0		beq.s	FinRecopieArgument		cmp.b	#'*',d0		beq.s	FinRecopieArgument		cmp.b	#';',d0		beq.s	FinRecopieArgument		cmp.b	#':',d0		beq.s	FinRecopieArgument		cmp.b	#$0e,d0		blo.s	FinRecopieArgument		cmp.b	#$20,d0						; caractère de contrôle ?		bhi.s	RecopieArgument_Cont		; non		adda.l	#1,a0				bra.s	RecopieArgument_Loop		; oui on passe au char suivantRecopieArgument_Cont		; non donc on le place dans le buffer		; si minuscule => majuscule				cmp.b	#'a',d0		blo.s	PasMinuscule		cmp.b	#'z',d0		bhi.s	PasMinuscule; minuscule				and.b	#%11011111,d0		PasMinuscule		move.b	d0,1(a1,d7.w)		addq.W	#1,d7		bra.s	RecopieArgument_LoopFinRecopieArgument		move.b	d7,(a1)		add.l	d7,a0	; (a0)=char suivant l'étiquette		move.l	a0,a4		moveq	#0,d2; on regarde si c'est un argument immédiat		lea		buffer2(a6),a0		move.b	1(a0),d0		cmp.b	#'#',d0		bne.s	PasImmediat		; oui immédiat			bset	#15,d2; on décale le  buffer d'un				lea		buffer2(a6),a0		moveq	#0,d7		sub.b	#1,(a0)loop_DecaleTexte_1		move.b	2(a0,d7),d0		move.b	d0,1(a0,d7)		addq.w	#1,d7		cmp.b	(a0),d7		blo.s	loop_DecaleTexte_1; on a décaler le texte		; --PasImmediat					; on regarde si c'est une valeur héxa	($)		lea		buffer2(a6),a0		move.b	1(a0),d0		cmp.b	#'$',d0		bne.s	PasHexa	; oui immédiat			bset	#13,d2; on décale le  buffer d'un				lea		buffer2(a6),a0		moveq	#0,d7		sub.b	#1,(a0)loop_DecaleTexte_2		move.b	2(a0,d7),d0		move.b	d0,1(a0,d7)		addq.w	#1,d7		cmp.b	(a0),d7		blo.s	loop_DecaleTexte_2; on a décaler le texte	; --; on regarde si c'est une valeur binaire	(%)PasHexa			lea		buffer2(a6),a0		move.b	1(a0),d0		cmp.b	#'%',d0		bne.s	Pasbinaire; oui immédiat			bset	#12,d2; on décale le  buffer d'un				lea		buffer2(a6),a0		moveq	#0,d7		sub.b	#1,(a0)loop_DecaleTexte_3		move.b	2(a0,d7),d0		move.b	d0,1(a0,d7)		addq.w	#1,d7		cmp.b	(a0),d7		blO.s	loop_DecaleTexte_3; on a décaler le texte	; --Pasbinaire; on regarde si l'argument est une étiquette								lea		buffer2(a6),a0		bsr		GetEtiquetteValue		tst.l	d1		bne		PasEtiquette			; ce n'est pas une étiquette 		bset	#11,d2		bra	Exit		; ce n'est pas une étiquette, donc on continue l'étude de la chaîne de caractèrePasEtiquette		btst		#13,d2	; valeur héxa ?		bne.s		Valeur_Hexa		btst		#12,d2	; valeur binaire ?		bne.s		Valeur_binaire; --Valeur_decimal		lea		buffer2(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		movem.l	d2-d7/a1-a3,-(sp)		import	decimalascii_hexa		bsr		decimalascii_hexa		movem.l	(sp)+,d2-d7/a1-a3 		bra		Exit; --Valeur_Hexa		lea		buffer2(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		movem.l	d2-d7/a1-a3,-(sp)		import	hexascii_hexa		bsr		hexascii_hexa		movem.l	(sp)+,d2-d7/a1-a3 		bra		Exit; --Valeur_binaire				lea		buffer2(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		movem.l	d2-d7/a1-a3,-(sp)		import	binascii_hexa		bsr		binascii_hexa			movem.l	(sp)+,d2-d7/a1-a3 exit	rts		DbgInfo.new		findNextArgument		endP		* =======================================ErrorInListing proc export			rts			endP;ErrorInListing ;GetEtiquetteValue*;AddEtiquette *;WaitChar*;SetEtiquetteValue*;DoDirective;DoAssemble;calcEtiquettePtr *; routines s'occupant de la gestion des étiquettes;; Template in memory; number of étiquette dc.w; namelength dc.b	1; name		 dc.b	namelength; Flags		 dc.b	1		; b7=1 si pas de valeur attribuée; Value		 dc.l	2* =========================================* WaitChar()* =========================================;;  Cette routine attend une lettre et s'arrète dès que trouvé ; ou bien si elle trouve le caractères $OD (return);	elle positionne a4 sur le caractère trouvé;WaitChar proc export		cmp.b	#$0d,(a4)		;sommes nous sur un char de contrôle		beq.s	out_1	;non		cmp.b	#$00,(a4)		;sommes nous sur un char de contrôle		beq.s	out_1	;nonWaitChar_loop		move.b	(a4)+,d0		beq.s	Out				; char de contrôle		cmp.b	#$0d,d0		beq.s	Out				; char de contrôle		cmp.b	#$41,d0		blo.s	WaitChar_loop		; pas majuscule		cmp.b	#$61,d0			; minuscule ?		bge.s	Minuscule		cmp.b	#$5a,d0			; pas majuscule		bhi.s	WaitChar_loop		bra.s	OutMinuscule		cmp.b	#$7a,d0			; pas minuscule		bhi.s	WaitChar_loopOut		suba.l	#1,a4out_1	rts		DbgInfo.New	WaitChar		endP* =========================================* WaitChar_Special()* =========================================;;  Cette routine attend une lettre  ou une virgule ;  et s'arrète dès que trouvé ;  ou bien si elle trouve le caractères $OD (return);	elle positionne a4 sur le caractère trouvé;WaitChar_Special proc export		cmp.b	#',',(a4)		beq.s	out_1	;non		cmp.b	#$0d,(a4)		;sommes nous sur un char de contrôle		beq.s	out_1	;non		cmp.b	#$00,(a4)		;sommes nous sur un char de contrôle		beq.s	out_1	;nonWaitChar_loop		move.b	(a4)+,d0		beq.s	Out				; char de contrôle		cmp.b	#$0d,d0		beq.s	Out				; char de contrôle		cmp.b	#',',d0			; une virgule		beq.s	Out		cmp.b	#'#',d0			; une virgule		beq.s	Out		cmp.b	#'$',d0			; une virgule		beq.s	Out		cmp.b	#'%',d0			; une virgule		beq.s	Out		cmp.b	#$41,d0		blo.s	WaitChar_loop		; pas majuscule		cmp.b	#$61,d0			; minuscule ?		bge.s	Minuscule		cmp.b	#$5a,d0			; pas majuscule		bhi.s	WaitChar_loop		bra.s	OutMinuscule		cmp.b	#$7a,d0			; pas minuscule		bhi.s	WaitChar_loopOut		suba.l	#1,a4out_1	rts		DbgInfo.New	WaitChar_Special		endP				* ========================================* GetEtiquetteValue()* ========================================; cette routine recherche une étiquette ; dans la liste et retourne la valeur dans d0; d1  contient le code d'erreur; entrée: a0 *str255 ; sortie: d0= value dc.l;         d1=0 si étiquette existe  ;         d1=-1200 si n'existe pasGetEtiquetteValue		proc export		import	calcEtiquettePtr		movem.l	d2-d7/a1-a4,-(sp)	;sauvegarde des registres; on recherche dans la liste l'étiquette		move.l	a0,a4		moveq	#1,d7Find_Etiq_Loop		move.l	d7,d0		bsr		calcEtiquettePtr		tst.l	d1		beq.s	Find_Etiq_1		movem.l	(sp)+,d2-d7/a1-a4	;récupération des registres; le n° que vous avez demander, n'est pas attribué ...				rts		; on a un pointeur on effectue la comparaison de chaîne		Find_Etiq_1				move.l	a0,a3		move.l	a4,a1		import	cmpstr		bsr		cmpstr		tst.w	d0		beq.s	Find_Found_Etiq_2; pas ce pointeur là donc suivant		addq.l	#1,d7		bra.s	Find_Etiq_Loop		; on a trouvé la chaîne		Find_Found_Etiq_2		moveq	#0,d0		move.b	(a3),d0		addq.w	#2,d0	; flags; on aligne la value sur un mot		move.l	d0,d1		and.l	#$1,d1		beq.S	Aligned		addq.l	#1,d0Aligned; on lit la valeur				move.l	(a3,d0.w),d0		moveq	#0,d1		movem.l	(sp)+,d2-d7/a1-a4	;récupération des registres		rts		DbgInfo.New	GetEtiquetteValue		endP		* ========================================* SetEtiquetteValue()* ========================================; cette routine recherche une étiquette ; dans la liste et retourne la valeur dans d0; d1  contient le code d'erreur; entrée: a0 *str255; 		  d0= value dc.l	; sortie: d1=0 si étiquette existe  ;         d1=-1200 si n'existe pasSetEtiquetteValue	proc export		import	calcEtiquettePtr		movem.l	d2-d7/a1-a4,-(sp)	;sauvegarde des registres; on recherche dans la liste l'étiquette		move.l	a0,a4		move.l	d0,d6		moveq	#1,d7Find_Etiq_Loop				move.l	d7,d0		bsr		calcEtiquettePtr		tst.l	d1		beq.s	Find_Etiq_1		movem.l	(sp)+,d2-d7/a1-a4	;récupération des registres; le n° que vous avez demander, n'est pas attribué ...				rts		; on a un pointeur on effectue la comparaison de chaîne		Find_Etiq_1				move.l	a0,a3		move.l	a4,a1		import	cmpstr		bsr		cmpstr		tst.w	d0		beq.s	Find_Found_Etiq_2; pas ce pointeur là donc suivant		addq.l	#1,d7		bra.s	Find_Etiq_Loop		; on a trouvé la chaîne		Find_Found_Etiq_2		moveq	#0,d0		move.b	(a3),d0		addq.w	#2,d0	; flags; on aligne la value sur un mot		move.l	d0,d1		and.l	#$1,d1		beq.S	Aligned		addq.l	#1,d0Aligned; on lit la valeur		cmp.l	(a3,d0.w),d6		bne.s	PasEgal		move.l	#10000,d1		movem.l	(sp)+,d2-d7/a1-a4	;récupération des registres		rts			PasEgal		move.l	d6,(a3,d0.w)		moveq	#0,d1		movem.l	(sp)+,d2-d7/a1-a4	;récupération des registres		rts				DbgInfo.New	SetEtiquetteValue		endP* ========================================* calcEtiquettePtr()* ========================================;; cetteRoutine calcule le pointeur d'une étiquette dans la liste des étiquettes;;	entrée: d0 n°;	sortie: a0 le prt;;calcEtiquettePtr		proc export		movem.l	d2-d7/a1-a4,-(sp)	;sauvegarde des registres; on regarde si la valeur correspond au nombres d'étiquettes de la liste		clr.l	d1		move.l	G.EtiquetteZone,a0		tst.w	(a0)		bne.s	NotError1 		move.l	#-1200,d1		; liste videNotError1 		move.l	d0,d2		subq.w	#1,d2		cmp.w	(a0),d2		blo.s	CalcEtiq_1; le chiffre est trop grand				move.l	#-1200,d1; ok on continue		CalcEtiq_1				adda.l	#2,a0		tst.w	d2		beq.s	out			; c'est le premier 		subq.w	#1,d2				calcEtiquettePtr_Loop				moveq.l	#0,d0		add.b	(a0),d0	; longueur de l'étiquette		addq.w	#2,d0	; ptr du flags; on aligne la value sur un mot		btst 	#0,d0		beq.s	Aligned		addq.l	#1,d0Aligned		add.l	#8,d0	; les 2 mots long 		add.l	d0,a0		dbra	d2,calcEtiquettePtr_Loopout		movem.l	(sp)+,d2-d7/a1-a4	;récupération des registres		rts		DbgInfo.New	calcEtiquettePtr		endP* ========================================* AddEtiquette()* ========================================; ajoute une étiquette dans la liste		;;	a0= ptr*str255;   d0= valeur;   d1<0 si pas de valeur à attribuer >=0 dans le cas contraire				AddEtiquette 		proc export		movem.l	d2-d7/a1-a4,-(sp)	;sauvegarde des registres		and.b	#$80,d1			; on masque les autres bits		move.l	d1,d5		move.l	d0,d2			; sauvegarde value		move.l	a0,a4			; sauvegarde ptr		move.l	G.EtiquetteZone,a0		move.w	(a0),d0;		bne.s	CalcNextSpace;		move.w	#1,(a0);		adda.l	#1,a0;		bra.s	theRestCalcNextSpace				add.w	#1,d0			; dernière étiquette+1		bsr		calcEtiquettePtr	; pointeur de la nouvelle étiquettetheRest		move.l	a0,a3		move.l	a3,a1		move.l	a4,a0		import copySTR		jsr		CopySTR			; on recopie le texte		moveq	#0,d0		move.b	(a4),d0		move.b	d5,1(a3,d0.w)		; flag			addq.l	#2,d0			; nbchar+2; on aligne la value sur un mot		move.l	d0,d1		and.l	#$1,d1		beq.S	Aligned		addq.l	#1,d0Aligned		move.l	d2,(a3,d0.w)		; flag		move.l	G.EtiquetteZone,a2		add.w	#1,(a2)	; une étiquette de plus		moveq	#0,d1		movem.l	(sp)+,d2-d7/a1-a4	;récupération des registres		rts				DbgInfo.New	AddEtiquette 		endP										********************************************************************************									      **		routines de conversions					      **		format ascii -> hexa					      **		format hexa  -> ascii					      **									      *********************************************************************************					       |*	conversion hexa -> ascii	       |	*----------------------------------------------|*	entree:				       |*					       |	*	- D0 valeur a convertir		       |		*	- D1 longueur (1 a 32 bits)	       |	*	- A0 pointeur sur adresse memoire      |*----------------------------------------------|*	sortie:				       | *					       |	*	- A0 pointe sur le dernier caractere +1|*	- D1= erreur (ccr positionnne)	       | *----------------------------------------------|*	si erreur:			       |	*					       |*	- D0=0	                               |*	- D1=n0 d'erreur		       |	*					       |*	-1- erreur de syntaxe		       |	*	-2- depassement			       |*----------------------------------------------|*					       |*	conversion ascii -> hexa	       |*----------------------------------------------|*	entree:				       |*					       |*	- A0 pointe sur le premier caractere   |*	- D0=0 chaine finie par $00            |*	  D0=longueur de la chaine	       |	*----------------------------------------------|*	sortie:				       |*					       |*	- D0=valeur			       |*	- A0 pointe sur caractere suivant      |*	- D1=erreur (ccr positione) 	       |*----------------------------------------------|*	si erreur:			       |	*					       |*	- D0=0	                               |*	- D1=n0 d'erreur		       |	*					       |*	-1- erreur de syntaxe		       |	*	-2- depassement			       |*----------------------------------------------| * ======================================================*	PROCEDURE	NumToSTRAscii(num : longint)* ======================================================*	conversion num -> ascii Décimal	       |	*----------------------------------------------|*	entree:				       |*					       |	*	- D0 valeur a convertir		       |		*	- A0 pointeur sur adresse memoire      |*----------------------------------------------|NumToSTRAscii		proc		export		movem.l	d0-d7/a1-a4,-(sp)		move.l	a0,a4		adda.l	#1,a0		move.l	#32,d1		move.l	d0,d2		lea	tablepuissancede10(pc),a1		move.l	a1,a2		moveq	#1,d5		cmp.l	#32,d1		bgt	conversion_exitoverflow		cmp.b	#8,d1		bgt	hexa_decimalascii1		add.l	#8,a2		bra	hexa_decimalascii3hexa_decimalascii1:		cmp.b	#16,d1		bgt	hexa_decimalascii2			add.l	#16,a2		bra	hexa_decimalascii3hexa_decimalascii2:		add.l	#40,a2hexa_decimalascii3:		cmp.l	(a2),d0		bge	hexa_decimalascii6hexa_decimalascii4:		sub.l	#4,a2		tst.l	d0		bne	hexa_decimalascii5		move.b	#$30,d3		move.b	d3,(a0)+		move.l	d2,d0		rtshexa_decimalascii5:		tst.l	d5		bne	hexa_decimalascii3					move.b	#$30,d3		move.b	d3,(a0)+		bra	hexa_decimalascii3hexa_decimalascii6:		move.l	(a2),d4		clr.l	d3		clr.l	d5hexa_decimalascii7:		cmp.l	d4,d0		blo	hexa_decimalascii8		add.l	(a2),d4		addq	#1,d3		bra	hexa_decimalascii7hexa_decimalascii8:		add.b	#$30,d3		move.b	d3,(a0)+		sub.l	(a2),d4		sub.l	d4,d0		blo	hexa_decimalascii9		sub.l	#4,a2		bra	hexa_decimalascii3hexa_decimalascii9:		move.l	d2,d0				movem.l	(sp)+,d0-d7/a1-a4		rtsconversion_exitoverflow		moveq	#2,d1		movem.l	(sp)+,d0-d7/a1-a4		rtstablepuissancede10:		dc.l	1		dc.l	10		dc.l	100		dc.l	1000		dc.l	10000		dc.l	100000		dc.l	1000000		dc.l	10000000		dc.l	100000000		dc.l	1000000000					DBGINFO.new	NumToStrDEc		endp								*********	conversion hexa -> hexaasciihexa_hexascii:		proc export		move.l	d1,d2		cmp.b	#32,d1		bgt	conversion_exitoverflow		asr.b	#2,d1		and.l	#3,d2		beq	hexa_hexascii1		addq	#1,d1hexa_hexascii1:		move.l	d0,d2		add.l	d1,a0		move.l	a0,a1hexa_hexascii2:		move.b	d2,d0		and.b	#$f,d0		add.b	#$30,d0		cmp.b	#$39,d0		bls	hexa_hexascii3		add.b	#7,d0hexa_hexascii3:		move.b	d0,-(a1)		lsr.l	#4,d2					subq	#1,d1		bne	hexa_hexascii2		rtsconversion_exitoverflow		moveq	#2,d1		movem.l	(sp)+,d0-d7/a1-a4		rts		DBGINFO.new		NumToStHex		endp*********	conversion hexa -> binaire	*********	hexa_binascii:		proc export		move.l	d0,d2		cmp.l	#32,d1		bgt	conversion_exitoverflow		move.l	a0,a1		add.l	d1,a1hexa_binascii1:		lsr.l	#1,d2		bcc	hexa_binascii2		move.b	#$31,d0		bra	hexa_binascii3hexa_binascii2:		move.b	#$30,d0hexa_binascii3:		move.b	d0,-(a1)				cmp.l	a1,a0		blo	hexa_binascii1		add.l	d1,a0		rtsconversion_exitoverflow		moveq	#2,d1		movem.l	(sp)+,d0-d7/a1-a4		rts				DBGINFO.new		NumToStrBin		endp*********	conversion decimalascii -> D0	*********decimalascii_hexa		PROC	export		move.l	d0,d4		clr.l	d0		clr.l	d1		clr.l	d3		lea	tablepuissancede10(pc),a3		move.l	a0,a1decimalascii_hexa1:		move.b	(a1)+,d0		addq	#1,d3		tst.b	d4		bne	decimalascii_hexa2		cmp.b	#10,d3		bgt	conversion_exitoverflow		tst.b	d0		beq	decimalascii_hexa3		bra	decimalascii_hexa1decimalascii_hexa2:		cmp.b	d3,d4		bge	decimalascii_hexa1decimalascii_hexa3:		sub.l	#1,a1		move.l	a1,a2 decimalascii_hexa4:		move.b	-(a1),d0		sub.b	#$30,d0		blo	conversion_exitsyntaxerror		cmp.b	#9,d0		bgt	conversion_exitsyntaxerrordecimalascii_hexa5:		sub.b	#1,d0		bmi	decimalascii_hexa6		add.l	(a3),d1		bra	decimalascii_hexa5decimalascii_hexa6:		add.l	#4,a3		cmp.l	a0,a1		bgt	decimalascii_hexa4		move.l	a2,a0conversion_exitok:		move.l	d1,d0		clr.l	d1		rtsconversion_exitoverflow:		clr.l	d0		moveq	#2,d1		rtsconversion_exitsyntaxerror:		clr.l	d0		moveq	#1,d1		rts		tablepuissancede10:		dc.l	1		dc.l	10		dc.l	100		dc.l	1000		dc.l	10000		dc.l	100000		dc.l	1000000		dc.l	10000000		dc.l	100000000		dc.l	1000000000				DBGINFO.new		decimalascii_hexa		endp						*********	conversion hexascii -> hexa	*********				hexascii_hexa:	PROC	EXPORT			move.l	d0,d4		clr.l	d0		clr.l	d1		clr.l	d3hexascii_hexa1:		move.b	(a0)+,d0		tst.b	d4		beq	hexascii_hexa2		addq	#1,d3		cmp.b	d4,d3		bhi	conversion_exitok		asl.l	#4,d1		bra	hexascii_hexa3hexascii_hexa2:		tst.b	d0		beq	conversion_exitok		asl.l	#4,d1hexascii_hexa3:		sub.b	#$30,d0		tst.b	d0		bmi	conversion_exitsyntaxerror		cmp.b	#9,d0		bls	hexascii_hexa4		sub.b	#7,d0		cmp.b	#$f,d0		bgt	conversion_exitsyntaxerrorhexascii_hexa4:		or.b	d0,d1		bra	hexascii_hexa1		conversion_exitok:		move.l	d1,d0		clr.l	d1		rtsconversion_exitoverflow:		clr.l	d0		moveq	#2,d1		rtsconversion_exitsyntaxerror:		clr.l	d0		moveq	#1,d1		rts				DBGINFO.new		hexascii_hexa		ENDP		*********	conversion binascii -> hexa	*********binascii_hexa:	proc export		move.l	d0,d4		clr.l	d0		clr.l	d1		clr.l	d3binascii_hexa1:		move.b	(a0)+,d0		tst.b	d4		beq	binascii_hexa2		addq	#1,d3		cmp.b	d4,d3		bhi	conversion_exitok		asl.l	#1,d1		bra	binascii_hexa3binascii_hexa2:		tst.b	d0		beq	conversion_exitok		asl.l	#1,d1		bra	binascii_hexa3	binascii_hexa3				cmp.b	#$31,d0		beq	binascii_hexa4		cmp.b	#$30,d0		beq	binascii_hexa5		bra	conversion_exitsyntaxerrorbinascii_hexa4:		or.l	#1,d1binascii_hexa5:				bra	binascii_hexa1*********	sortie				*********conversion_exitok:		move.l	d1,d0		clr.l	d1		rtsconversion_exitoverflow:		clr.l	d0		moveq	#2,d1		rtsconversion_exitsyntaxerror:		clr.l	d0		moveq	#1,d1		rts								DBGINFO.new		binascii_hexa		ENDP* ==============================* CmpStr(a0,a1)* ==============================; compare les string pointée par a0 et a1; resultat dans d0: 0= égale <>0 différente		CmpStr	proc export				movem.l	d2,-(sp)		moveq	#0,d2		move.b	(a0)+,d2		move.b	(a1)+,d1		cmp.b	d1,d2		bne.s	PasEgal				subq.w	#1,d2		loop	move.b	(a0)+,d0		move.b	(a1)+,d1				cmp.b	#'a',d0		blo		loop1		cmp.b	#'z',d0		bhi		loop1		and.b	#$df,d0loop1				cmp.b	#'a',d1		blo		loop2		cmp.b	#'z',d1		bhi		loop2		and.b	#$df,d1loop2				cmp.b	d0,d1		bne.s	PasEgal		dbra	d2,loop		egal	moveq	#0,d0				movem.l	(sp)+,d2		rts	PasEgal	moveq	#1,d0		movem.l	(sp)+,d2		rts							DbgInfo.New	CmpStr						end* ==============================* CmpStr(a0,a1)* ==============================; compare les string pointée par a0 et a1; resultat dans d0: 0= égale <>0 différente		CmpStr	proc export		movem.l	d1,-(sp)		clr.w	-(sp)		moveq	#0,d0		moveq	#0,d1		move.b	(a0)+,d0		move.b	(a1)+,d1		move.l	a0,-(sp)		move.l	a1,-(sp)		move.w	d0,-(sp)		move.w	d1,-(sp)		_IUMagIDString		move.w	(sp)+,d0		movem.l	(sp)+,d1		rts		DbgInfo.New	CmpStr				End