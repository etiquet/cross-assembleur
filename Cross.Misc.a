	PRINT	PUSH,OFF				INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'Cross.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'Aliases.a'	INCLUDE	'PrEqu.a'	INCLUDE	'PrintTrapsEqu.a'	; pour utiliser le printing manager	PRINT	POP		IMPORT	QD:QDGlobals	IMPORT	G:AppGlobals* ================================================* FUNCTION TrapAvailable(tNumber: INTEGER): BOOLEAN;* ================================================* Check to see if a given trap is implemented. This is only used by the* Initialize routine in this program, so we put it in the Initialize segment.* The recommended approach to see if a trap is implemented is to see if* the address of the trap routine is the same as the address of the* Unimplemented trap. Needs to be called after call to _SysEnvirons so that it can* check if a ToolTrap is out of range of a pre-Mac II ROM.  This routine* assumes we're running on 128k ROMs. It also requires the entire trap* word so that it knows if it is a ToolTrap or an OSTrap.		SEG	'Initialize'		; case sensitiveTrapAvailable	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointtNumber		DS.W	1			; the trap number passed by callerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTrapAddress	DS.L	1			; local copy of trap addressLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#False,Result(A6)	; initialize function's result		MOVE.W	tNumber(A6),D0		; get trap word into D0		BTST	#ToolTrapBit,D0		; test if number is Tool trap		BEQ.S	GetOSTrap		; off means a new OS trap number				MOVE.W	G.Mac.machineType,D1	; get the machine type we're running		CMPI.W	#envMachUnknown,D1	; are we on a future machine?		BEQ.S	GetToolTrap		; yes, go ahead and test for a new Tool trap				CMPI.W	#envMacII,D1		; are we on a Mac II or better?		BGE.S	GetToolTrap		; yes, go ahead and test for a new Tool trap* ------------- TEST FOR EXCEEDING TRAP TABLE -------------* At this point we know we're on a Mac 512E, Plus, or SE and need to* test the trap number for being in the range of < $0200		AND.W	#$03FF,D0		; mask off the ToolTrap bits		CMPI.W	#$01FF,D0		; is this trap in our trap table?		BLE.S	GetToolTrap		; yes, go ahead and test for a new Tool trap		BRA.S	Exit			; no, then this trap cannot be present		* ------------- TEST FOR NEW TOOL TRAP -------------GetToolTrap	_GetTrapAddress ,NewTool	; NewTool trap macro, trap is in D0		MOVE.L	A0,TrapAddress(A6)	; save a copy of the trap address		BRA.S	TestUnimp		; test against Unimplemented trap		* ------------- TEST FOR NEW OS TRAP -------------GetOSTrap	_GetTrapAddress ,NewOS		; NewOS trap macro, trap is in D0		MOVE.L	A0,TrapAddress(A6)	; save a copy of the trap addressTestUnimp	MOVE.W	#Unimplemented,D0	; get address of Unimplemented trap		_GetTrapAddress		CMPA.L	TrapAddress(A6),A0	; see if trap is implemented		BEQ.S	Exit			; nope, they're the same		MOVE.W	#True,Result(A6)	; yes, we've got the trapExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	TrapAval		; this name will appear in the debugger		ENDF* ================================================* FUNCTION GoGetRect(rectID: INTEGER; VAR theRect: Rect) : BOOLEAN;* ================================================* This utility loads the global rectangles that are used by the window* drawing routines. It shows how the resource manager can be used to hold* values in a convenient manner. These values are then easily altered without* having to re-compile the source code. GoGetRect will return a BOOLEAN that* indicates if it was successful in getting the rectangle.* A0 is being used for resource handle.		SEG	'Initialize'		; case sensitiveGoGetRect	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointRectID		DS.W	1			; resource ID of rect passed by callerTheRect		DS.L	1			; the rect's pointer passed by callerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#False,Result(A6)	; initialize function's result		CLR.L	-(SP)			; create space for result		MOVE.L	#'RECT',-(SP)		MOVE.W	RectID(A6),-(SP)	; get the stop light's rect		_GetResource		MOVEA.L	(SP)+,A0		; handle to RECT resource in A0		CMPA.L	#NIL,A0			; test for NIL handle		BEQ.S	Exit			; didn't get resource, exit this procedure* -------- COPY THE RESOURCE TO THE RECT --------		MOVE.W	#True,Result(A6)	; we got the resource, return true		MOVEA.L	(A0),A0			; pointer to RECT resource in A0		MOVEA.L	TheRect(A6),A1		; pointer to the dest. RECT in A1		MOVE.L	topLeft(A0),topLeft(A1)	; copy to the rect passed to us		MOVE.L	botRight(A0),botRight(A1)Exit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	GetRect			; this name will appear in the debugger		ENDF* ================================================* FUNCTION IsDAWindow(window: WindowPtr): BOOLEAN;* ================================================* Check if a window belongs to a desk accessory.  DA window has a negitive kind.		SEG	'Main'IsDAWindow	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointTheWindow	DS.L	1			; a window's pointer passed by callerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#False,Result(A6)	; first, initialize the result		CMPI.L	#NIL,TheWindow(A6)	; valid pointer?		BEQ.S	Exit			; it was NIL, look out!		MOVEA.L	TheWindow(A6),A0	; get the window pointer		MOVE.W	WindowKind(A0),D0	; what kind of window was it?		BPL.S	Exit			; DA windows are negitive		MOVE.W	#True,Result(A6)	; return true to the callerExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	IsDAWind		; this name will appear in the debugger		ENDF* ================================================* FUNCTION IsAppWindow(window: WindowPtr): BOOLEAN;* ================================================* Check to see if a window belongs to the application. If the window pointer* passed was NIL, then it could not be an application window. WindowKinds* that are negative belong to the system and windowKinds less than userKind* are reserved by Apple except for windowKinds equal to dialogKind, which* means it is a dialog.* In order to reduce the chance of accidentally treating some window* as an AppWindow that shouldn't be, we'll only return true if the windowkind* is userKind. If you add different kinds of windows to Sample you'll need* to change how this all works.		SEG	'Main'IsAppWindow	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointTheWindow	DS.L	1			; a window's pointer passed by callerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#False,Result(A6)	; first, initialize the result		CMPI.L	#NIL,TheWindow(A6)	; valid pointer?		BEQ.S	Exit			; it was NIL, look out!		MOVEA.L	TheWindow(A6),A0	; get the window pointer		MOVE.W	WindowKind(A0),D0	; what kind of window was it?		CMPI.W	#UserKind,D0		; was it an application window?		BNE.S	Exit			; no, result is going to be false		MOVE.W	#True,Result(A6)	; return true to the callerExit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	IsAppWin		; this name will appear in the debugger		ENDF* ================================================* PROCEDURE AlertUser;* ================================================* Display an alert that tells the user an error occurred, then exit the program.* This routine is used as an ultimate bail-out for serious errors that prohibit* the continuation of the application. Errors that do not require the termination* of the application should be handled in a different manner. Error checking and* reporting has a place even in the simplest application. For simplicity, the alert* displayed here only says that an error occurred, but not what it was. There are* various methods available for being more specific.		SEG	'Main'		; case sensitiveAlertUser	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		CLR.W	-(SP)			; space for result of Alert		MOVE.W	#rUserAlert,-(SP)	; resource for alert dialog		CLR.L	-(SP)			; no filter procedure used here		_Alert				; read the resource and display it		MOVE.W	(SP)+,D0		; I don't care which item is was		_ExitToShell			; we're out of here, no error recoveryExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	AlrtUser		; this name will appear in the debugger		align 4			ENDP* ================================================* FUNCTION DoCloseWindow(window: WindowPtr) : BOOLEAN;* ================================================* At this point, if there was a document associated with a window, you could* do any document saving processing if it is 'dirty'.  DoCloseWindow would* return TRUE if the window actually closes, i.e., the user does not cancel* from a save dialog. This result is handy when the user quits an application,* but then cancels a save of a document associated with a window. We also added* code to close the application window since otherwise, the termination routines* would never stop looping, waiting for FrontWindow to return NIL. 		SEG	'Main'			; case sensitiveDoCloseWindow	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointWindowPtr	DS.L	1			; passed window pointer parameterParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#True,Result(A6);	; initialize the function's result		CLR.W	-(SP)			; space for result of IsDAWindow		MOVE.L	WindowPtr(A6),-(SP)	; pass the window pointer		jsr	IsDAWindow		MOVE.W	(SP)+,D0		; result of IsDAWindow		CMPI.W	#True,D0		BNE.S	@1			; this wasn't a DA window		MOVEA.L	WindowPtr(A6),A0	; get window pointer		MOVE.W	WindowKind(A0),-(SP)	; pass the refNum of DA		_CloseDeskAcc		BRA.S	Exit			; all done@1		CLR.W	-(SP)			; space for result of IsAppWindow		MOVE.L	WindowPtr(A6),-(SP)	; pass a the window pointer		jsr	IsAppWindow		MOVE.W	(SP)+,D0		; result of IsAppWindow		CMPI.W	#True,D0		BNE.S	Exit			; it wasn't our application's window		MOVE.L	WindowPtr(A6),-(SP)	; close window, it shouldn't be a dialog		_CloseWindow			; close the application windowExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ClosWind		; this name will appear in the debugger		ENDF* ================================================* PROCEDURE Terminate;* ================================================* Clean up the application and exit. We close all of the windows so that* they can update their documents, if any.  We don't have much to do here.* Just close our windows and then exit.  If we find out that a Cancel has* occurred (DoCloseWindow will return False) we won't exit to the shell,* but will simply exit this procedure.		SEG	'Main'			; case sensitiveTerminate	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkWindowPtr	DS.L	1			; local variable for a window pointerClosed		DS.W	1			; local variable for loopingLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	DoCloseWindow		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#True,Closed(A6)	; initialize local variable		_PrClose				; on ferme le printingManager   		Loop	CLR.L	-(SP)			; space for front window pointer		_FrontWindow		MOVE.L	(SP)+,WindowPtr(A6)	; get the front window pointer		CMPI.L	#NIL,WindowPtr(A6)	; is there a front window?		BEQ.S	@1			; there are no more windows		CLR.W	-(SP)			; space for result of DoCloseWindow		MOVE.L	WindowPtr(A6),-(SP)	; pass the window pointer		jsr	DoCloseWindow		; close all our windows		MOVE.W	(SP)+,Closed(A6)	; get result of DoCloseWindow		CMPI.W	#True,Closed(A6)	; what's the result of DoCloseWindow?		BNE.S	Exit			; user didn't want to close that window		BRA.S	Loop			; loop again and close the next window@1		CMPI.W	#True,Closed(A6)	; should we really terminate?		BNE.S	Exit			; no, exit this procedure				_ExitToShell			; we're done, let's get out of hereExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	Terminat		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE AdjustMenus;* ================================================* Enable and disable menus based on the current state.  The user can only select* enabled menu items. We set up all the menu items before calling MenuSelect or* MenuKey, since these are the only times that a menu item can be selected. Note* that MenuSelect is also the only time the user will see menu items. This* approach to deciding what enable/disable state a menu item has the advantage* of concentrating all the decision making in one routine, as opposed to being* spread throughout the application.  Other application designs may take a* different approach that are just as valid.		SEG	'Main'			; case sensitiveAdjustMenus	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkFrontMost	DS.L	1			; local copy of the front windowMenu		DS.L	1			; local copy of the menu handlemode		ds.w	1aStyle		ds.b	12LocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame* ------------- ADJUST THE EDIT MENU -------------AdjustEdit				CLR.L	-(SP)			; space for result		MOVE.W	#130,-(SP)		; get the Edit menu handle		_GetMHandle		MOVE.L	(SP)+,Menu(A6)		; save the menu handle				MOVE.L	Menu(A6),-(SP)			MOVE.W	#CutItem,-(SP)		_EnableItem			; enable the Cut		MOVE.L	Menu(A6),-(SP)		; it was for a DA window		MOVE.W	#PreferenceItem,-(SP)		_EnableItem			; enable the Cut		MOVE.L	Menu(A6),-(SP)	; active le préférenceitems		MOVE.W	#2,-(SP)		_EnableItem			MOVE.L	Menu(A6),-(SP)		MOVE.W	#CopyItem,-(SP)		_EnableItem			; enable the Copy		MOVE.L	Menu(A6),-(SP)		MOVE.W	#PasteItem,-(SP)		_EnableItem			; enable the Paste		MOVE.L	Menu(A6),-(SP)		MOVE.W	#ClearItem,-(SP)		_EnableItem			; enable the Clear; attention faire test si check item ou non et commentExit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	AdjstMnu		; this name will appear in the debugger		align 4			ENDP* =============================================================================* PROCEDURE	DoGrowWindow(window: WindowPtr,MinNewSize : rectPtr *						  MaxNewSize: rect Ptr, Where: Point)* =============================================================================; MaxNewSize = taille maximum de la fenètre losrqu'elle est dessinée en pointillé; Where = Défini l'endroit où la souris à été pointée		SEG	'Main'			; case sensitiveDoGrowWindow	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWindowPtr	DS.L	1		; passed parameter of the window pointerMaxNewSize	DS.L	1		; taille maximale de la fenètreWhere		DS.L	1		; lieu où a été pointer la sourisParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR				WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d1-d3,-(sp)				move.l	WindowPtr(a6),-(sp)			_setPort		clr.l	-(sp) 	;valeur en retour		move.l	WindowPtr(a6),-(sp)			MOVE.L	Where(A6),-(SP)			move.l	MaxNewSize(a6),-(sp)		_GrowWindow		move.l	(sp)+,d0			beq		Exit		; o ne fait rien		move.l	WindowPtr(a6),-(sp)		move.l	d0,-(sp)		move.w	#true,-(sp)		_SizeWindow  ; on laisse la valeur dans la pile pour tout à l'heure.		move.l	(sp)+,d0	; on recupère la valeur dans la pile			; on invalide la région de la fenètre pour forcer un UPDATE EVENT; on invalide la région de la fenètre pour forcer un UPDATE EVENT		move.l	WindowPtr(a6),a0		pea		portRect(a0)		_InvalRect								Exit	MOVEM.L	(SP)+,D1-D3	; on recupère les contenus antérieurs des registres		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP	; strip all of the caller's parameters				JMP	(A0)			; return to the caller		DbgInfo.New	DoGrowWindow		; this name will appear in the debugger		align 4			ENDP		* =============================================================================* PROCEDURE	DoZoomWindow(window: WindowPtr, Where: Point*						,partCode: integer): boolean	* =============================================================================; routine qui retaille la fenètre à une valeur maximale, ou minimale ; cf inside mac page IV-50		SEG	'Main'			; case sensitiveDoZoomWindow	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWindowPtr	DS.L	1		; passed parameter of the window pointerWhere		DS.L	1		; lieu où a été pointé la sourispartCode	DS.w	1		; variable contenant soit zoom in soit zoom outParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR				WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d1-d3,-(sp)		move.l	WindowPtr(a6),-(sp)		move.l	where(a6),-(sp)		move.w	partCode(a6),-(sp)		_TrackBox		move.w	(sp)+,d0		beq		PasZoomDemande					; on invalide la région de la fenètre pour forcer un UPDATE EVENT		move.l	WindowPtr(a6),a0		pea		portRect(a0)		_InvalRect		move.l	WindowPtr(a6),-(sp)		move.w	partCode(a6),-(sp)		move.w	#true,-(sp)				_ZoomWindow		bra		Exit		PasZoomDemande:		adda.l	#4,sp				Exit	MOVEM.L	(SP)+,D1-D3	; on recupère les contenus antérieurs des registres		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP	; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	DoZoomWindow		; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE GetGlobalMouse(VAR mouse: Point);* ================================================* Get the global coordinates of the mouse. When you call OSEventAvail* it will return either a pending event or a null event. In either case,* the where field of the event record will contain the current position* of the mouse in global coordinates and the modifiers field will reflect* the current state of the modifiers. Another way to get the global* coordinates is to call GetMouse and LocalToGlobal, but that requires* being sure that thePort is set to a valid port.}		SEG	'Main'			; case sensitiveGetGlobalMouse	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointMouse		DS.L	1			; passed reference to mouse positionParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTheEvent 	DS	EventRecord 		; local copy of the event recordLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#NoEvents,D0		; we aren't interested in any events		LEA	TheEvent(A6),A0		; point to event record		_OSEventAvail			; just the mouse position		MOVE.L	Mouse(A6),A0		; deref address of mouse		MOVE.L	TheEvent.Where(A6),(A0)	; stuff new value		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	GetGlobalMouse		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE AdjustCursor(mouse: Point; region: RgnHandle);* ================================================* Change the cursor's shape, depending on its position. This also calculates the* region where the current cursor resides (for WaitNextEvent). If the mouse is* ever outside of that region, an event would be generated, causing this routine* to be called, allowing us to change the region to the region the mouse is* currently in. If there is more to the event than just the mouse moved, we* get called before the event is processed to make sure the cursor is the right* one. In any (ahem) event, this is called again before we fall back into WNE.* 1.02 - Removed the mouse position parameter and instead use the current position* of the mouse by calling GetMouse and LocalToGlobal.		SEG	'Main'			; case sensitiveAdjustCursor PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWhere		DS.L	1			; the mouse location passed to usMouseRegion	DS.L	1			; passed pointer to current regionParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkFrontMost	DS.L	1			; local pointer to the front windowDesktopRgn	DS.L	1			; local handle to the arrow cursor regionCursorRgn	DS.L	1			; local handle to the plus cursor regionrectangle	ds		rectLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	IsDAWindow,IsAppWindow		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		 		CMPI.W	#True,G.InBackground	;on regarde si l'application est active 		BEQ 	Exit					; non, donc on ne fait rien		CLR.L	-(SP)					; space for result of FrontWindow		_FrontWindow					; push front window pointer		MOVE.L	(SP)+,FrontMost(A6)		; copy pointer and keep it on stack; on créé une region; CursorRgn		CLR.L	-(SP)		_NewRgn				; create an empty plus region		MOVE.L	(SP)+,CursorRgn(A6)		; on regarde si la fenètre est une fenètre à nous				lea.l	G.ListingWindow,a0		cmp.l	FrontMost(A6),a0		beq		listing				lea.l	G.ErrorWindow,a0		cmp.l	FrontMost(A6),a0		beq		error		bra		Exit; -------; pour l'instant, on ne s'occupe pas des autres fenètreserror			; on definie la region du TE => curseur RGN				pea.l	G.ErrorWindow		_setPort; on recopie le rectangle du texte edit		move.l	G.ErrorTE,a0		move.l	(a0),a0			; handle		move.l	TeViewRect(a0),rectangle(a6)		move.l	4+TeViewRect(a0),4+rectangle(a6); conversion => global		pea		rectangle(a6)		_LocalToGlobal		pea		4+rectangle(a6)		_LocalToGlobal; on définie la region		move.l	CursorRgn(a6),-(sp)		pea		Rectangle(a6)		_rectRgn; on regarde si le point est dedans					clr.w	-(sp)		move.l	Where(a6),-(sp)		move.l	CursorRgn(a6),-(sp)		_PtinRgn		move.w	(sp)+,d0		bne		CurseurTexte		; oui donc curseur texte; non pas dans le texte edit		; -------;PASDETE_Error		pea.l	G.Errorwindow		_setPort; on définie la zone anti-mouse moved comme le port rect		lea.l	G.ErrorWindow,a0		move.l	CursorRgn(a6),-(sp)		pea		portRect(a0)		_rectRgn		bra		curseurFleche		; ------------------------------------------------------Listing; on definie la region du TE => curseur RGN				pea.l	G.ListingWindow		_setPort; on recopie le rectangle du texte edit		move.l	G.ListingTE,a0		move.l	(a0),a0			; handle		move.l	TeViewRect(a0),rectangle(a6)		move.l	4+TeViewRect(a0),4+rectangle(a6); conversion => global		pea		rectangle(a6)		_LocalToGlobal		pea		4+rectangle(a6)		_LocalToGlobal; on définie la region (en global)		move.l	CursorRgn(a6),-(sp)		pea		Rectangle(a6)		_rectRgn; on regarde si le point est dedans					clr.w	-(sp)		move.l	Where(a6),-(sp)		move.l	CursorRgn(a6),-(sp)		_PtinRgn		move.w	(sp)+,d0		bne		CurseurTexte		; oui donc curseur texte; non pas dans le texte edit		; -------;PASDETE_Listing		pea.l	G.ListingWindow		_setPort; on définie la zone anti-mouse moved comme le port rect		lea.l	G.ListingWindow,a0		move.l	CursorRgn(a6),-(sp)		pea		portRect(a0)		_rectRgn		bra		curseurFleche; ----------------------------------------------------------------------------------curseurFleche				pea	QD.Arrow		_SetCursor		_ShowCursor				move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra	Exit; ---curseurFlecheCreuse		clr.l	-(sp)		move.w	#287,-(sp)		_GetCursor		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	curseurFlecheCreuse1		move.l	(a0),a0		; handle		move.L	a0,-(sp)		_SetCursor		_ShowCursorcurseurFlecheCreuse1				move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra	Exit; ---curseurTexte		clr.l	-(sp)		move.w	#139,-(sp)		_GetCursor		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	curseurTexte1		move.l	(a0),a0		; handle		move.L	a0,-(sp)		_SetCursor		_ShowCursorcurseurTexte1		move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra		Exit; ---curseurLoupe		clr.l	-(sp)		move.w	#141,-(sp)		_GetCursor		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	curseurLoupe1		move.l	(a0),a0		; handle		move.L	a0,-(sp)		_SetCursor		_ShowCursorcurseurLoupe1		move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	AdjustCursor		; this name will appear in the debugger		align 4			ENDP* ***************************************************************** *                                                              ** * FONCTIONS SPECIALES POUR LES ROUTINES SYSTEME TRACK CONTROL  ** *                                                              ** ***************************************************************** =====================================================================* PROCEDURE WaitTicks(Ticks: Longinteger);* =====================================================================* Cette routine attends un certains nombre de temps donné par Ticks* un ticks correspond environ à 1/60 ème de secondes *		SEG	'Main'			; case sensitiveWaitTicks	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointTicks		ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 link 			DS.L	1			; emplacement pour stocker la taille et positionRectfenetre	DS.L	1			; de la fenètreMouseLoc	ds.l	1			; point de la sourisTheEvent 	DS	EventRecord 		; local copy of the event recordMouseMvdRgn	DS.L	1			; local region for MouseMoved eventsMousePos	DS.L	1			; local point for mouse positionWticks		ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT DrawListingWindow,DrawWindow		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		; sauvegarde des registres qui vont ètre détruits par cette routine		movem.l	d0-d7/a0-a4,-(sp)		clr.l	-(sp)		_TickCount		move.l	(sp)+,d0		add.l	Ticks(a6),d0		move.l	d0,Wticks(a6)				CLR.L	-(SP)		_NewRgn				; create region for AdjustCursor		MOVE.L	(SP)+,MouseMvdRgn(A6)	; save the handle to this region						* ------------- GET NEXT EVENT LOOP -------------NextEvent			CMPI.W	#True,G.HasWNEvent 	; see if we can call WaitNextEvent		BNE.S	WT_1			; nope, old time events				PEA	MousePos(A6)		; here's the mouse		jsr	GetGlobalMouse		; get global coordinate		MOVE.L	MousePos(A6),-(SP)	; here's the mouse		MOVE.L	MouseMvdRgn(A6),-(SP)	; the region to change		jsr	AdjustCursor		; adjust the cursor and region		CLR.W	-(SP)			; space for result		MOVE.W	#0,-(SP)	; nous ne voulons aucun event exepté ticks		PEA	TheEvent(A6)		; pointer to the event record		MOVE.L	Ticks(a6),-(SP)	; the sleeping time value		MOVE.L	MouseMvdRgn(A6),-(SP)	; the current MouseRgn		_WaitNextEvent		MOVE.L	TheEvent.where(A6),-(SP); the mouse location		MOVE.L	MouseMvdRgn(A6),-(SP)	; the region to change		jsr	AdjustCursor		; adjust cursor BEFORE doing event		BRA.S	Exit			; ok on a attendu le temps en question							; no WaitNextEvent trap availableWT_1		_SystemTask			; call SystemTask for drivers and DAs		CLR.W	-(SP)			; space for result		MOVE.W	#0,-(SP)	; the events we want		PEA	TheEvent(A6)		; pass a pointer to our event		_GetNextEvent		clr.l	-(sp)GotEvent	MOVE.L	TheEvent.where(A6),-(SP); the mouse location		MOVE.L	MouseMvdRgn(A6),-(SP)	; the region to change		jsr	AdjustCursor		; adjust cursor BEFORE doing event		_TickCount		move.l	(sp)+,d0		cmp.l	Wticks(a6),d0		blt 	WT_1	; on boucle jusqu'a que le temps soit dépasser	Exit	MOVEM.L	(SP)+,D0-D7/A0-A4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.New	WaitTicks	; this name will appear in the debugger		align 4			ENDP** !!!!!!!!!! la meme chose mais pour initialise* =====================================================================* PROCEDURE Waitaicks(Ticks: Longinteger);* =====================================================================* Cette routine attends un certains nombre de temps donné par Ticks* un ticks correspond environ à 1/60 ème de secondes *		SEG	'Initialize'			; case sensitiveWaitaicks	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointTicks		ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 link 			DS.L	1			; emplacement pour stocker la taille et positionRectfenetre	DS.L	1			; de la fenètreMouseLoc	ds.l	1			; point de la sourisTheEvent 	DS	EventRecord 		; local copy of the event recordMouseMvdRgn	DS.L	1			; local region for MouseMoved eventsMousePos	DS.L	1			; local point for mouse positionWticks		ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR				WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		; sauvegarde des registres qui vont ètre détruits par cette routine		movem.l	d0-d7/a0-a4,-(sp)		clr.l	-(sp)		_TickCount		move.l	(sp)+,d0		add.l	Ticks(a6),d0		move.l	d0,Wticks(a6)loop	clr.l	-(sp)		_TickCount		move.l	(sp)+,d0		cmp.l	Wticks(a6),d0		blt.s	loopExit	MOVEM.L	(SP)+,D0-D7/A0-A4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.New	Waitaicks	; this name will appear in the debugger		align 4			ENDP		* =====================================================================* PROCEDURE SelectWindow(theWindow; ptr);* =====================================================================* Cette routine effectue le même boulot que _SelectWindow, à la différence* que si le flag Preference_SaisieLock equ true la fenètre saisie,* reste toujours devant les autres .		SEG	'Main'			; case sensitiveSelectWindow	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointthewindow	ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR				WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		; sauvegarde des registres qui vont ètre détruits par cette routine		movem.l	d0-d7/a0-a4,-(sp)		move.l	thewindow(a6),-(sp)		_SelectWindowExit	MOVEM.L	(SP)+,D0-D7/A0-A4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.New	SelctWind	; this name will appear in the debugger		align 4			ENDP* =============================================================================* PROCEDURE	UpdateControlsDansLaFenetre (window: WindowPtr)* =============================================================================; CETTE procédure prend comme paramètre un pointeur de fenètre,  recalcule; la position des scroll bars appelle la fct Draws Controls,; car la routine appellante a effacé le contenu de la fenètre,; (en principe sinon cela fera des choses bizarres à l'écran)		SEG	'Main'			; case sensitiveUpdateControlsDansLaFenetre 	PROC	EXPORT			; any source file can use this routine	StackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointWindowPtr		DS.L	1		; passed parameter of the window pointerParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linksaveA0			ds.l	1Recttopleft		DS.L	1			; emplacement pour stocker la taille et positionRectfenetre		DS.L	1			; de la fenètreCurentControl	DS.L	1			; case pour sauvegarder le handle du control en 									; cours de traitement.VisRect		DS.L	rectregion			ds.l	1											LocalSize	EQU 	*			; size of all the local variables		ENDR				WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame; sauvegardes des registres				movem.l	d1-d4/a1-a4,-(sp)		;  on verifie s'i la fenètre contient des controls; seulement	window 2 et 3 en possèdent (pour l'instant) 		doControl					; il faut dire à QUICKDRAW que le port de la fenètre est le port courant		move.l	WindowPtr(a6),-(sp)		_SetPort; on  définie l'espace de dessin comme étant toute la fenètre		_PenNormal		; en attendant log ERIC:dossier DEVELOPPEMENT:sous-titrage :MacBugsLogging		; attention on effectue des manipulations dans la pile, l'ordre est inversé; par rapport à la mémoire standard les pointeurs pointent les eléments du bas pour ; renverser cette inversion . !!!; il faut trouver les dimensions de la fenètre en questions		; puis déterminer la taille et le placement du ou des scrolls bars; je pense qu'il faut utiliser le portRect pour cela ???		move.l	WindowPtr(a6),a0						; transfert de rect dans buffer temporaire		move.l	portRect(a0),Rectfenetre(a6)			move.l	portRect+4(a0),Rectfenetre+4(a6)			; boucle pour tester les différents controls, si c'est un control du type refcon = 1 ou 2; càd scroll bars on effectue les changements sinon on ne fait rien.; pour terminer on teste le "next controls" est si il est nul donc il n'y a plus de ; controls dans la fenètre; inititialisation du pointeur => a0		move.l	WindowPtr(a6),a0		adda.l	#wControlList,a0		; c'est un handle donc double indirection		move.l	(a0),a0; ! en théorie il faudrait locked le handle pendant la manipulation (multitache !); initialisation a1		move.l	WindowPtr(a6),a1		BoucleModifcontrols:		move.l	contrlOwner(a0),d0		cmp.l	WindowPtr(a6),d0		bne		Onpassealasuite; on cherche si le control en cours est le Vscrollbar control car le ref con=1 		move.l	contrlRfCon(a0),d0		cmp.l	#1,d0		bne 	ControlHorizontal		; ok c'est notre scroll bar refcon=1, control vertical		move.w	Rectfenetre+right(a6),d0		add.w	#1,d0		move.w	d0,contrlRect+right(a0)		sub.w	#16,d0		move.w	d0,contrlRect+left(a0)					move.w	Rectfenetre+top(a6),d0		add.w	#0,d0		move.w	d0,contrlRect+top(a0); on teste s'il y a un grow control ?		move.w	windowKind(a1),d0		and.w	#noGrowDocProc,d0		bne.s	PasGrowWindow; c'est donc une fenètre avec un growWindow, il faut enlever la hauteur de l'icon Grow		move.w	Rectfenetre+bottom(a6),d0		sub.w	#14,d0		move.w	d0,contrlRect+bottom(a0)		bra.s	continu		PasGrowWindow		move.w	Rectfenetre+bottom(a6),d0		add.w	#0,d0		move.w	d0,contrlRect+bottom(a0)		continu					bra.s	Onpassealasuite; pour l'intant il n'y en a plus		ControlHorizontal:		move.l	contrlRfCon(a0),d0		cmp.l	#2,d0		bne.s	Onpassealasuite		; ok c'est notre scroll bar refcon=2		move.w	Rectfenetre+left(a6),d0		add.w	#0,d0		move.w	d0,contrlRect+left(a0)						move.w	Rectfenetre+bottom(a6),d0		add.w	#1,d0		move.w	d0,contrlRect+bottom(a0)		sub.w	#16,d0		move.w	d0,contrlRect+top(a0); on teste s'il y a un grow control ?		move.w	windowKind(a1),d0		and.w	#noGrowDocProc,d0		bne.s	PasGrowWindow2; c'est donc une fenètre avec un growWindow, il faut enlever la hauteur de l'icon Grow		move.w	Rectfenetre+right(a6),d0		sub.w	#14,d0		move.w	d0,contrlRect+right(a0)		bra.s	continu		PasGrowWindow2		move.w	Rectfenetre+right(a6),d0		add.w	#0,d0		move.w	d0,contrlRect+right(a0)		continu2				bra.s	Onpassealasuite; on prend le control suivant dans la liste, ou bien on arrete si le ptr=0	Onpassealasuite:		move.l	(a0),a0		cmp.l	#0,a0		bne		BoucleModifcontrols		; on a fini donc on affiche les controls		move.l	WindowPtr(a6),-(sp)		_DrawControls	****		Exit	movem.l	(sp)+,d1-d4/a1-a4; on recupère les contenus antérieurs des registres		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP	; strip all of the caller's parameters				JMP	(A0)			; return to the caller		DbgInfo.New	UpdateControlsDansLaFenetre ; this name will appear in the debugger		align 4			ENDP* =====================================================================* PROCEDURE ControlActionProc(control: ctrlHandle, partCode: integer);* =====================================================================* The window's visRgn has been set by the Update routine * to cause drawing only where it needs to be done.		SEG	'Main'			; case sensitiveControlActionProc	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWichControl	DS.L	1			; passed parameter of the controlPartCode	DS.W	1			; partcode pour le controlParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkItemType	ds.w	1ItemHandle	ds.l	1itemRect	ds	rectrectangle	ds	rectregion		ds.l	1			; une régionNumST		ds.w	1handleTE	ds.l	1RECTFENETRE	ds	RectnbDeStAafficher	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT DrawListingWindow,DrawWindow,ConversionNumeroSTPointeur,\				ConversionASCIIbcdTc,SoustractionTimeCode,ConversionTCstASCII,\				AdditionTimeCode		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		; sauvegarde des registres qui vont ètre détruits par cette routine		movem.l	d0-d4/a0-a4,-(sp)				clr.l	-(sp)		_FrontWindow		move.l	(sp)+,d0		lea		G.ListingWindow,a0		cmp.l	D0,a0		bne.s	PASListing		move.l	G.ListingTE,HandleTE(a6)		bra.S	DoTheREstPASListing		lea		G.ErrorWindow,a0		cmp.l	D0,a0		bne 	Exit		move.l	G.ErrorTE,HandleTE(a6)DoTheREst		move.l	WichControl(a6),a0		move.l	(a0),a0		; c'est un handle donc double indirection; 	on cherche de quel control il s'agit:		move.l	contrlRfCon(a0),d0		Case#.w	(d0,IF),			\			(1,FaireVScroll),	\			(2,FaireHScroll) 		BRA	exit; on gère les controls tc in et tc out saisie* ----------- on effectue le action proc pour hScroll control-------* ----------- on effectue le action proc pour VScroll control-------FaireVScroll:		move.w	PartCode(a6),d0		Case#.W	(d0,IF),			\			(InUpButton,V_FaireMinusOne),	\			(InDownButton,V_FairePlusOne),	\			(InPageDown,V_FairePlusPage),	\			(InPageUp,V_FaireMinusPage)		bra	Exit	FaireHScroll:		move.w	PartCode(a6),d0		Case#.W	(d0,IF),			\			(InUpButton,H_FaireMinusOne),	\			(InDownButton,H_FairePlusOne),	\			(InPageDown,H_FairePlusPage),	\			(InPageUp,H_FaireMinusPage)		bra	Exit* --------------- V_doMinusOne ---------------------V_FaireMinusOne:		clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		beq		Exit		; on ne fait rien		subq.w	#1,d0				move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl				move.l	HandleTE(a6),a0		move.l	(a0),a0		move.w	TelineHite(a0),d1						move.w	#0,-(sp)		move.w	d1,-(sp)		move.l	HandleTE(a6),-(sp)		_TEPinScroll		bra		Exit		* --------------- H_doMinusOne ---------------------H_FaireMinusOne:		clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		beq		Exit		; on ne fait rien		subq.w	#1,d0				move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl				move.w	#1,-(sp)		move.w	#0,-(sp)		move.l	HandleTE(a6),-(sp)		_TEScroll		bra		Exit* --------------- V_doPlusOne ---------------------V_FairePlusOne:		clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		addq.w	#1,d0				move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl				move.l	HandleTE(a6),a0		move.l	(a0),a0		move.w	TelineHite(a0),d1				neg.w	d1		move.w	#0,-(sp)		move.w	d1,-(sp)		move.l	HandleTE(a6),-(sp)		_TEPinScroll		bra		Exit		* --------------- H_doPlusOne ---------------------H_FairePlusOne:		clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		addq.w	#1,d0				move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl				move.w	#-1,-(sp)		move.w	#0,-(sp)		move.l	HandleTE(a6),-(sp)		_TEScroll		bra		Exit		* --------------- V_doMinusPage ---------------------V_FaireMinusPage:				move.l	HandleTE(a6),a0		move.l	(a0),a0		move.w	TelineHite(a0),d7						move.w	bottom+TeViewRect(a0),d6		sub.w	top+TeViewRect(a0),d6		and.l	#$ffff,d6		divu	d7,d6		subq.w	#1,d6			; nombre de ligne -1		bpl.s	@1		moveq	#1,d6@1				clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move	(sp)+,d0		sub.w	d6,d0			bpl.s	@2		moveq	#0,d0@2		move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl		mulu	d7,d6		move.w	#0,-(sp)		move.w	d6,-(sp)		move.l	HandleTE(a6),-(sp)		_TEPinScroll		bra		Exit		* --------------- H_doMinusPage ---------------------H_FaireMinusPage:		clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		sub.w	#10,d0				move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl		move.w	#-10,-(sp)		move.w	#0,-(sp)		move.l	HandleTE(a6),-(sp)		_TEScroll		bra		Exit* --------------- V_doPlusPage ---------------------V_FairePlusPage:		move.l	HandleTE(a6),a0		move.l	(a0),a0		move.w	TelineHite(a0),d7						move.w	bottom+TeViewRect(a0),d6		sub.w	top+TeViewRect(a0),d6		and.l	#$ffff,d6		divu	d7,d6		subq.w	#1,d6		bpl.s	@1		moveq	#1,d6@1				clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		add.w	d6,d0			move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl		mulu	d7,d6		neg.w	d6		move.w	#0,-(sp)		move.w	d6,-(sp)		move.l	HandleTE(a6),-(sp)		_TEPinScroll		bra		Exit		* --------------- H_doPlusPage ---------------------H_FairePlusPage:		clr.w	-(sp)		; POUR LE RESULTAT		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		add.w	#10,d0				move.l	WichControl(a6),-(sp)		move.w	d0,-(sp)		_SetCtlValue		move.l	WichControl(a6),-(sp)		_ShowControl				move.w	#10,-(sp)		move.w	#0,-(sp)		move.l	HandleTE(a6),-(sp)		_TEPinScroll		bra		Exit				Exit	MOVEM.L	(SP)+,D0-D4/A0-A4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ControlActionProc		; this name will appear in the debugger		align 4			ENDP					END    ; fin de ce listing