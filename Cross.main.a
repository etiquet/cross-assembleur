* ************************************************* *                                              ** * 		    Bon BOUGRE     					 ** *          Listing principal					 ** *												 ** ************************************************; ????	DebugStr "Turn Discipline ON; DSCA ON; G"* =========================================* -------------- INCLUDES  ----------------* =========================================		PRINT	PUSH,OFF				INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'Cross.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'Aliases.a'	INCLUDE	'PrEqu.a'	INCLUDE	'PrintTrapsEqu.a'	; pour utiliser le printing manager	PRINT	POP					* ================================================* ---------  DATA STORAGE ALLOCATION  ------------* ================================================* Global data storage.  All global memory is allocated here.  The* Linker will load all global data offset from A5, and the Asm knows this.* Therefore, no reference to (A5) is required in the code. Hooray!* Here we declare two data structures using our templates defined previously.* They must be EXPORTed here for other files that need to IMPORT them.		EXPORT	(QD,G):DATAQD		DS	MyQDGlobals		; QuickDraw's globalsG		DS	AppGlobals		; application's globals* ================================================* PROCEDURE Initialize;* ================================================* Set up the whole world, including global variables, Toolbox managers, and menus.* Check to see if a given trap is implemented. The recommended approach to see if* a trap is implemented is to see if the address of the trap routine is the same* as the address of the Unimplemented trap.  We also create our one application* window at this time. * initialisation		SEG 'Initialize'		; case sensitiveInitialize	PROC				; Initialize everythingCountReg	EQU	D4			; temporary registor to count loopsStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkCurMBar		DS.L	1			; local handle to our menubarstore		ds.l	1TheEvent 	DS		EventRecord 		; local copy of the event recorditemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		Rect	; rectanglecurseur 	Ds.W	1rectangle	ds		Rectrefnum		ds.w	1SerStat		ds.b	6SerialBuffer	ds.b	256LocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	GoGetRect,AlertUser,SysEnvirons,EffaceTouslesSousTitres,\			TrapAvailable,Waitaicks,DoUpdate,DoActivate,Show_cursor,\			InitCursorCtl,SpinCursor,RAMSDOpen,\			SerReset,SerSetBuff,SerHShake,SerStatus,OpenDriver,\			FSRead,FSWrite,Control,Status,KillIO		; linked in with Interface.o		WITH	StackFrame 	; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				MOVEM.L	d4-d7,-(SP) 		; save the current registor values	* ------------- INITIALIZE MANAGERS -------------		@1		PEA 	QD.GrafPort 		; initialize all of the Managers		_InitGraf			; please don't flush my events		_InitFonts		_InitWindows		_InitMenus		_TEInit		CLR.L	-(SP)			_InitDialogs		_InitCursor		_InitAllPacks		_PrOpen* Call MPPOpen and ATPLoad at this point to initialize AppleTalk, if you are using it.* NOTE -- It is no longer necessary, and actually unhealthy, to check PortBUse and* SPConfig before opening AppleTalk. The drivers are capable of checking for port* availability themselves.  This next bit of code is necessary to allow the default* button of our alert be outlined.* ------------- GET THE ENVIRONMENT -------------		CLR.W	-(SP)			; create space for result		MOVE.W	#EnvironsVersion,-(SP)	; version of SysEnvirons we want		PEA	G.Mac			; the global environment record		JSR	SysEnvirons		; we can ignore any errors here,		MOVE.W	(SP)+,D0		; SysEnvirons will fill in regardless		MOVE.W	G.Mac.MachineType,D0 	; negitive value means old ROMs		BPL.S	@2			; 128k ROMs or better, continue on		JMP	AlertUser		; we don't want to run on 64k ROMs* ------------- TEST FOR WAITNEXTEVENT -------------* 1.02 - Move TrapAvailable call to after SysEnvirons so that* we can tell in TrapAvailable if a tool trap value is out of range.@2		CLR.W	-(SP)			; space for result of trap test		MOVE.W	#WaitNextEvent,-(SP)	; pass the trap number of WaitNextEvent trap		jsr	TrapAvailable		; test for this trap		MOVE.W	(SP)+,G.HasWNEvent	; put the result in our global flag			* ------------- CHECK FOR ENOUGH MEMORY -------------* It is better to first check the size of the application heap against a value* that you have determined is the smallest heap the application can reasonably* work in. This number should be derived by examining the size of the heap that* is actually provided by MultiFinder when the minimum size requested is used.* The derivation of the minimum size requested from MultiFinder is described* in ASample.r. The check should be made because the preferred size can end up* being set smaller than the minimum size by the user. This extra check acts to* insure that your application is starting from a solid memory foundation. *    IF applLimit - applZone < MinHeap THEN AlertUser* Next, make sure that enough memory is free for your application to run. It* is possible for a situation to arise where the heap may have been of required* size, but a large scrap was loaded which left too little memory. To check for* this, call PurgeSpace and compare the result with a value that you have determined* is the minimum amount of free memory your application needs at initialization.* This number can be derived several different ways. One way that is fairly* straightforward is to run the application in the minimum size configuration* as described previously. Call PurgeSpace at initialization and examine the value* returned. However, you should make sure that this result is not being modified* by the scrap's presence. You can do that by calling ZeroScrap before calling* PurgeSpace. Make sure to remove that call before shipping, though. * The extra benefit to waiting until after the Toolbox Managers have been initialized* before checking memory is that we can now give the user an alert to tell him what* happened. Although it is possible that the memory situation could be worsened by* displaying an alert, MultiFinder would gracefully exit the application with* an informative alert if memory became critical. Here we are acting more* in a preventative manner to avoid future disaster from low-memory problems. 		MOVE.L	applLimit,D1		; get pointer to ApplLimit		MOVE.L	applZone,D0		; get pointer to ApplicZone		SUB.L	D0,D1			; subtract the ApplicZone from ApplLimit		CMPI.L	#MinHeap,D1		; do we have enough memory?		BPL.S	@3			; yes we do, continue on		JMP	AlertUser		; no, report the error		@3		_PurgeSpace			; results will be in A0 and D0		CMPI.L	#MinSpace,D0		; do we have enough purgeable space?		BPL.S	@4		JMP	AlertUser		; no, report the error* -------------- Maintenant on aloue un espace de travail en mémoire -----; on prend pour l'instant l'espace mémoire actuellemement Disponible; sauf on laisse:;		- 600K pour les opération échange et calcul; 		- 10k pour le buffer Undo; 		- 50k en reserve (on ne sait jamais)@4					clr.l	-(sp)		move.l	#'acur',-(SP)		MOVE.W	#129,-(SP)		_GetResource		MOVE.L	(SP),D0		JSR 	InitCursorCtl				_MaxMem		sub.l	#(200+50+10)*1024,d0		cmp.l	#300*1024,d0		bgt.s	Init_AssezDeMemoire				CLR.W	-(SP)			; space for result of Alert		MOVE.W	#132,-(SP)	; resource for alert dialog		CLR.L	-(SP)			; no filter procedure used here		_Alert				; read the resource and display it		MOVE.W	(SP)+,D0		; I don't care which item is was		_ExitToShell			; we're out of here, no error recovery					Init_AssezDeMemoire		MOVE.L	#100*1024,D0		move.l	d0,store(a6)		_NewPtr ,CLEAR 		MOVE.L A0,G.BufferTexte		add.l	Store(a6),a0		MOVE.L	a0,G.Text_HIMEM		; mémoire pour le buffer d'erreur 		MOVE.L	#200*1024,D0		move.l	d0,store(a6)		_NewPtr	,CLEAR		MOVE.L	A0,G.errorBuffer		add.l	Store(a6),a0		MOVE.L	a0,G.error_HIMEM; 32 k pour l'image de la rom		MOVE.L	#64*1024,D0		MOVE.L	d0,store(a6)		_NewPtr	,CLEAR		MOVE.L	A0,G.RomImage		add.l	store(a6),a0		move.l	a0,G.Rom_Himem; 32 k pour la liste d'étiquette		MOVE.L	#64*1024,D0		MOVE.L	d0,store(a6)		_NewPtr	,CLEAR		MOVE.L	A0,G.EtiquetteZone		add.l	store(a6),a0		move.l	a0,G.Etiquette_Himem; on aligne le pointeur sur dc.l		move.l	G.EtiquetteZone,d0		move.l	d0,d1		divu	#4,d1		swap	d1		and.l	#$ffff,d1		add.l	d1,d0		move.l	d0,G.EtiquetteZone* ----------- ouverture des fenètres ------------------; utilisation de resourceouverturefenetre:;ouverture fenètre assembleur (fenètre 1)		move.w	#128,-(sp)		pea		G.ListingWindow		move.l	#-1,-(sp)		_GetNewWindow; on laisse la valeur dans la pile		move.l	#1,-(sp)		_SetWRefCon		move.w	#129,-(sp)		pea		G.ErrorWindow		move.l	#-1,-(sp)		_GetNewWindow; on laisse la valeur dans la pile		move.l	#2,-(sp)		_SetWRefCon	* ------- on place les contrôles standarts desfenètres -------	; le controle vertical	cont	move.w	#128,-(sp)		pea		G.ListingWindow		_GetNewControl		move.l	(sp),G.ListingVScroll		move.l	#1,-(sp)		_SetCRefCon		; le control horizontal		move.w	#128,-(sp)		pea		G.ListingWindow		_GetNewControl		move.l	(sp),G.ListingHScroll		move.l	#2,-(sp)		_SetCRefCon						move.l	G.listingHscroll,-(sp)		move.w	#0,-(sp)		_SetMinCtl		move.l	G.listingHscroll,-(sp)		move.w	#50,-(sp)		_SetMaxCtl		move.l	G.listingHscroll,-(sp)		move.w	#1,-(sp)		_SetCtlValue						move.l	G.ListingVscroll,-(sp)		move.w	#0,-(sp)		_SetMinCtl		move.l	G.ListingVscroll,-(sp)		move.w	#1,-(sp)		_SetMaxCtl		move.l	G.ListingVscroll,-(sp)		move.w	#1,-(sp)		_SetCtlvalue; pour la fenètre erreur				move.w	#128,-(sp)		pea		G.ErrorWindow		_GetNewControl		move.l	(sp),G.ErrorVScroll		move.l	#1,-(sp)		_SetCRefCon		; le controle horizontal		move.w	#128,-(sp)		pea		G.ErrorWindow		_GetNewControl		move.l	(sp),G.ErrorHScroll		move.l	#2,-(sp)		_SetCRefCon				move.l	G.errorHscroll,-(sp)		move.w	#0,-(sp)		_SetMinCtl		move.l	G.errorHscroll,-(sp)		move.w	#50,-(sp)		_SetMaxCtl		move.l	G.errorHscroll,-(sp)		move.w	#0,-(sp)		_SetCtlValue		move.l	G.errorVscroll,-(sp)		move.w	#0,-(sp)		_SetMinCtl		move.l	G.errorVscroll,-(sp)		move.w	#1,-(sp)		_SetMaxCtl		move.l	G.errorVscroll,-(sp)		move.w	#1,-(sp)		_SetCtlvalue; on place la fenètres au milieu de l'écran 				pea	G.ListingWindow		_ShowWindow		pea	G.ListingWindow		_SelectWindow	************************************************	; on ouvre 2 te 1 pour listing 1 pour erreur	pea		G.listingWindow	_SetPort	move.w	#monaco,-(sp)	_TextFont	move.w	#9,-(sp)	_TextSize	lea		G.listingWindow,a0	move.l	PortRect(a0),rectangle(a6)	move.l	4+PortRect(a0),4+rectangle(a6)	sub.w	#15,bottom+rectangle(a6)	sub.w	#18,right+rectangle(a6)	add.w	#10,left+rectangle(a6)	add.w	#3,top+rectangle(a6)	clr.l	-(sp)	pea		rectangle(a6)	pea		rectangle(a6)	_TENew	move.l	(sp)+,G.ListingTE		move.w	#true,-(sp)	move.l	G.ListingTE,-(sp)	_TEAutoView		move.l	G.ListingTE,-(sp)	_TEActivate		Pea		G.ErrorWindow	_setPort	move.w	#monaco,-(sp)	_TextFont	move.w	#9,-(sp)	_TextSize	lea		G.ErrorWindow,a0	move.l	PortRect(a0),rectangle(a6)	move.l	4+PortRect(a0),4+rectangle(a6)	sub.w	#18,bottom+rectangle(a6)	sub.w	#15,right+rectangle(a6)	add.w	#10,left+rectangle(a6)	add.w	#3,top+rectangle(a6)		clr.l	-(sp)	pea		rectangle(a6)	pea		rectangle(a6)	_TENew	move.l	(sp)+,G.ErrorTE		move.w	#true,-(sp)	move.l	G.ErrorTE,-(sp)	_TEAutoView	pea		G.listingWindow	_SetPort			clr.l	-(sp)		_zeroScrap		move.l	(sp)+,d0	* ------------- SET UP THE MENUS -------------			CLR.L	-(SP)			; space for MenuBar handle		MOVE.W	#rMenuBar,-(SP)		; our MenuBar resource		_GetNewMBar			; the modern way, get a MenuBar		MOVE.L	(SP),CurMBar(A6)		_SetMenuBar		MOVEA.L	CurMBar(A6),A0		; we're done with that handle		_DisposHandle			; there is a result in D0		CLR.L	-(SP)		MOVE.W	#AppleMenu,-(SP)		_GetMHandle			; put Apple menu handle on stack		MOVE.L	#'DRVR',-(SP)		; get all the DAs		_AddResMenu		_DrawMenuBar		clr.l	-(sp)		move.w	#134,-(sp)		_GetRMenu 	; resultat dans la pile		move.w	#-1,-(sp)		_InsertMenu		clr.l	-(sp)		move.w	#135,-(sp)		_GetRMenu 	; resultat dans la pile		move.w	#-1,-(sp)		_InsertMenu		clr.l	-(sp)		move.w	#136,-(sp)		_GetRMenu 	; resultat dans la pile		move.w	#-1,-(sp)		_InsertMenu		* ---------------------------------------------; activation des items des menus		move.W	#129,-(sp)		_GetMHandle		move.W	#5,-(sp)		_EnableItem				move.W	#129,-(sp)		_GetMHandle		move.W	#2,-(sp)		_EnableItem		; on lit la resource Data 129 op code 6305		clr.l	-(sp)		move.l	#'Data',-(sp)		move.w	#129,-(sp)		_GetResource		move.l	(sp)+,G.ResourceDATA129	; maintenant on regarde si le finder nous demande d'ouvrir un dossier et de l'imprimerLookFinder				move.l	AppParmHandle,a0; handle donc ..		cmp.l	#0,a0		beq.s	Exit	; Il n'y a rien que diable		move.l	(a0),a0	; on a un pointeur		move.w	2(a0),d0		beq		Exit	; y a rien à faire						Pea		4(a0)		import	DoFileOpen		Jsr		DoFileOpen	; on passe le message au file open		cmp.l	#-1,d0		beq		Exit	; il y a eu un petit problème				move.l	AppParmHandle,a0					; d0=code erreur 0= ok		move.w	(a0),d0		cmp.w	#1,d0	; print le document ? 		bra.s	PasPrintDocument		;?					PasPrintDocument; ok on a fini;		move.w	4(a0),-(sp)		clr.l	6(a0)	; comme cela le finder sait que nous avons manager des fichiers	Exit	move.w	#$0505,-(sp)	; on place le bon curseur		jsr		Show_cursor		MOVEM.L	(SP)+,d4-d7		; restore the registors		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller		string pascalMODEMPORTNAME	dc.b	'.AIn' sershk	dc.b	0		dc.b	0		dc.b	0		dc.b	0		dc.b	64+32+16		dc.b	0		dc.b	0		dc.b	0		Configuration	dc.w	(4+16384+3072)						DbgInfo.New	Initialize		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE GetMainScreenRes(Rectangle: *Rect); * ================================================*	*	Cette routine retourne les dimensions h & v de l'écran principal,*	ainsi que ses coordonnées*GetMainScreenRes 	PROC	EXPORT				SEG	'Traitement'StackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointRectanglePtr	ds.l	1					; adresse du rectangle pour retourParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR								WITH	StackFrame		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame						movem.l	a1,-(sp)				tst.b	G.Mac.HasColorQD 				bne.s	ColorQuickDraw				move.l	RectanglePtr(a6),a0				move.l	QD.ScreenBits.bounds.TopLeft,topleft(a0)				move.l	QD.ScreenBits.bounds.BotRight,BotRight(a0)				bra.s	Exit; -ColorQuickDraw				move.l	MainDevice,a1				move.l	(a1),a1		; c'est un handle				move.l	RectanglePtr(a6),a0				move.l	gdRect(a1),topLeft(a0) 				;y ,x début écran				move.l	gdRect+BotRight(a1),BotRight(a0)	;h,w taille écran	Exit			movem.l	(sp)+,a1				UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)				DbgInfo	GetMainScreenRes			; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE DoUpdate(window: WindowPtr);* ================================================* This is called when an update event is received for a window.* It calls DrawWindow to draw the contents of an application window.* As an efficiency measure that does not have to be followed, it* calls the drawing routine only if the visRgn is non-empty. This* will handle situations where calculations for drawing or drawing* itself is very time-consuming.		SEG	'affichage'			; case sensitiveDoUpdate	PROC	exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWindowPtr	DS.L	1			; passed parameter of the window pointerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkwindowReferencenumber	ds.l	1rectangle	ds	Rectregion		ds.l	1Rectfenetre	ds	RectVisRect		ds	RectLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,DrawWindow,UpdateControlsDansLaFenetre		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		;		CLR.W	-(SP)			; space for result of IsAppWindow;		MOVE.L	WindowPtr(A6),-(SP)	; pass the window pointer;		jsr	IsAppWindow			; test if this window was ours;		MOVE.W	(SP)+,D0		;		CMPI.W	#True,D0		; it must be our window;		BNE 	Exit			; it wasn't our window		_PenNormal			MOVE.L	WindowPtr(A6),-(SP)		_setPort		MOVE.L	WindowPtr(A6),-(SP)	; update only the visible region		_BeginUpDate			; region of the window		CLR.W	-(SP)			; space for result		MOVEA.L	WindowPtr(A6),A0	; the window pointer		MOVE.L	visRgn(A0),-(SP)	; the window's visRgn handle		_EmptyRgn		MOVE.W	(SP)+,D0		; result of EmptyRgn		CMPI.W	#True,D0		; was the visRgn empty?		BEQ 	FinUpdate			; yes, then no update is needed		MOVE.L	WindowPtr(A6),a0		pea	portRect(a0)		_EraseRect						MOVE.L	WindowPtr(A6),-(sp)		_DrawGrowIcon; routine qui redessine les controls d'une fenètre en fct des paramètres de cette; dernière .		MOVE.L	WindowPtr(A6),-(sp) ; on passe le pointeur de la fenètre en cours										jsr		UpdateControlsDansLaFenetre;on calcule la hauteur et largeur du te		move.l	WindowPtr(A6),a0		move.l	PortRect(a0),rectangle(a6)		move.l	4+PortRect(a0),4+rectangle(a6)		sub.w	#18,bottom+rectangle(a6)		sub.w	#15,right+rectangle(a6)		add.w	#10,left+rectangle(a6)		add.w	#3,top+rectangle(a6)		lea		G.ListingWindow,a0		cmp.l	WindowPtr(a6),a0		bne		PasListing				move.l	G.ListingTE,a0		move.l	(a0),a0		; handle		move.l	rectangle(a6),teviewRect(a0) 		move.l	4+rectangle(a6),4+teviewRect(a0) 		pea		teviewRect(a0) 		_EraseRect						move.l	G.ListingTE,a0		move.l	(a0),a1				; handle		pea		teviewRect(a1)		; tout le rectangle du te		move.l	a0,-(sp)		_TeUpdate			bra		FinUpdatePasListing		lea		G.ErrorWindow,a0		cmp.l	WindowPtr(a6),a0		bne		exit				move.l	G.ErrorTE,a0		move.l	(a0),a0		; handle		move.l	rectangle(a6),teviewRect(a0) 		move.l	4+rectangle(a6),4+teviewRect(a0) 		pea		teviewRect(a0) 		_EraseRect						move.l	G.ErrorTE,a0		move.l	(a0),a1				; handle		pea		teviewRect(a1)		; tout le rectangle du te		move.l	a0,-(sp)		_TeUpdateFinUpdate		MOVE.L	WindowPtr(A6),-(SP)	; get pointer to window		_EndUpdate		Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	DoUpdate		; this name will appear in the debugger		align 4			ENDP		* ================================================* PROCEDURE DoActivate(window: WindowPtr; becomingActive: BOOLEAN);* ================================================* In this sample there is no other processing necessary other than what* the Window Manager has already done for us.  This would be the place to* perform an activate on TextEdit records, controls, lists, update GrowIcon, etc.		SEG	'Main'			; case sensitiveDoActivate	PROC	align 4StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWindowPtr	DS.L	1			; passed parameter of the window pointerActive		DS.W	1			; modifiers from the event recordParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkItemRect	ds		RectLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow		IMPORT	UpdateControlsDansLaFenetre		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				CMPI.W	#True,Active(A6)	; was it an Activate?		BNE		DeActivate		; no, perform a Deactivate		* do the activate event processing here, then "BRA.S   Exit"			lea		G.ListingWindow,a0		cmpa.l	WindowPtr(a6),a0		beq		doListingactivate					lea		G.errorWindow,a0		cmpa.l	WindowPtr(a6),a0		beq		DoerrorActivate		bra	Exit; ----		doListingactivate				MOVE.L	WindowPtr(A6),-(SP)			_DrawGrowIcon				move.l	G.ListingTE,-(sp)		_TeActivate; activation des controls scroll bars				move.l	WindowPtr(a6),a0		adda.l	#wControlList,a0			move.l	(a0),a0; ! en théorie il faudrait locked le handle pendant la manipulation (multitache !); initialisation a1BoucleModifcontrols2		move.l	contrlRfCon(a0),d0		cmp.l	#1,d0		beq 	OkOnChange2		cmp.l	#2,d0		beq 	OkOnChange2		bra.s	suite2OkOnChange2:; on rend les scrolls bars visibles		move.b	#255,contrlVis(a0)                                                                      suite2:		move.l	(a0),a0		cmp.l	#0,a0		bne		BoucleModifcontrols2		 		pea		G.ListingWindow  ; on passe le pointeur de la fenètre en cours								 		jsr		UpdateControlsDansLaFenetre		bra 	Exit; -----------------doerroractivate				MOVE.L	WindowPtr(A6),-(SP)			_DrawGrowIcon				move.l	G.ErrorTE,-(sp)		_TeActivate; activation des controls scroll bars				move.l	WindowPtr(a6),a0		adda.l	#wControlList,a0			move.l	(a0),a0; ! en théorie il faudrait locked le handle pendant la manipulation (multitache !); initialisation a1error_BoucleModifcontrols2		move.l	contrlRfCon(a0),d0		cmp.l	#1,d0		beq 	error_OkOnChange2		cmp.l	#2,d0		beq 	error_OkOnChange2		bra.s	error_suite2error_OkOnChange2:; on rend les scrolls bars visibles		move.b	#255,contrlVis(a0)                                                                      error_suite2:		move.l	(a0),a0		cmp.l	#0,a0		bne		error_BoucleModifcontrols2		 		pea		G.ErrorWindow  ; on passe le pointeur de la fenètre en cours								 		jsr		UpdateControlsDansLaFenetre		bra 	Exit				; ---------------------		DeActivate					; do the deactivate event		* do the deactivate event processing here, then fall through to Exit			; on verifie s'i la fenètre contient des controls; seulement	window 2 en possède (pour l'instant)				lea		G.ListingWindow,a0		cmpa.l	WindowPtr(a6),a0		beq		ListingDesactivate						lea		G.errorWindow,a0		cmpa.l	WindowPtr(a6),a0		beq		ErrorDesActivate				bra	Exit;------		ListingDesactivate					pea		G.ListingWindow		_SetPort		move.l	G.listingTE,-(sp)		_TeDeactivate				; inactivation des controls scroll bars				move.l	WindowPtr(a6),a0		adda.l	#wControlList,a0		move.l	(a0),a0; ! en théorie il faudrait locked le handle pendant la manipulation (multitache !); initialisation a1BoucleModifcontrols		move.l	contrlRfCon(a0),d0		cmp.l	#1,d0		beq 	OkOnChange		cmp.l	#2,d0		beq 	OkOnChange		bra.s	suiteOkOnChange:; on efface les scrolls bars		move.b	#0,contrlVis(a0)		; on accquier le port pour notre fenètre		move.l	a0,-(sp)	; on sauvegarde a0				MOVE.L	WindowPtr(A6),-(SP)		_SetPort	; on a le port				move.l	(sp),a0				pea		contrlRect(a0)		_EraseRect				move.l	(sp)+,a0	; on recupère a0suite:		move.l	(a0),a0		cmp.l	#0,a0		bne		BoucleModifcontrols				pea		G.ListingWindow  ; on passe le pointeur de la fenètre en cours										jsr		UpdateControlsDansLaFenetreGrowIcon				MOVE.L	WindowPtr(A6),-(SP)			_DrawGrowIcon		bra		Exit; -----------------------------------------		ErrorDesactivate			pea		G.ErrorWindow		_SetPort		move.l	G.ErrorTE,-(sp)		_TeDeactivate		; inactivation des controls scroll bars				move.l	WindowPtr(a6),a0		adda.l	#wControlList,a0		move.l	(a0),a0error_BoucleModifcontrols		move.l	contrlRfCon(a0),d0		cmp.l	#1,d0		beq 	Error_OkOnChange		cmp.l	#2,d0		beq 	Error_OkOnChange		bra.s	Error_suiteerror_OkOnChange:; on efface les scrolls bars		move.b	#0,contrlVis(a0)		; on accquier le port pour notre fenètre		move.l	a0,-(sp)	; on sauvegarde a0				MOVE.L	WindowPtr(A6),-(SP)		_SetPort	; on a le port				move.l	(sp),a0				pea		contrlRect(a0)		_EraseRect				move.l	(sp)+,a0	; on recupère a0error_suite:		move.l	(a0),a0		cmp.l	#0,a0		bne		Error_BoucleModifcontrols				pea		G.ErrorWindow  ; on passe le pointeur de la fenètre en cours										jsr		UpdateControlsDansLaFenetreerror_GrowIcon				MOVE.L	WindowPtr(A6),-(SP)			_DrawGrowIcon				Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	Activate		; this name will appear in the debugger		align 4			ENDP					* ================================================* PROCEDURE DoMenuCommand(menuResult: LONGINT);* ================================================* This is called when an item is chosen from the menu bar (after calling* MenuSelect or MenuKey). It performs the right operation for each command.* It is good to have both the result of MenuSelect and MenuKey go to* one routine like this to keep everything organized.		SEG	'Main'			; case sensitiveDoMenuCommand	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointMenuItem		DS.W	1			; result from _MenuKey or _MenuSelectMenuID			DS.W	1			; caller passed a long word, ID + ItemParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkDeskname		DS.B	256			; local storage for Desk Accs nameTempPort		DS.L	1			; local storage for the current portTheItemHitalert	ds.w	1Menu			ds.l	1			; STOCKAGE handle menuTheDialogPtr	DS.l	1		; le pointeur local du dialogItemchoisi		DS.W	1		; Item choisi par l'utilisateuritemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		ds 		RectDialogStorage	ds	dWindLenVisRect			ds		Rectrectangle		ds		Rectstpos			ds.w	1Buffer			ds.b	256windowPtr		ds.l	1STScrp			ds.l	1TexteStyle		ds.b	12mode			ds.w	1SelStyle		ds.w	1LocalSize		EQU 	*			; size of all the local variables				ENDR				IMPORT	DoCloseWindow,Terminate,\				SelectWindow,saveData,DoGetSaveName,DoFileOpen,ExportFichier									;Imprimer,PageSetup		WITH	StackFrame 		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		clr.l	-(sp)		_FrontWindow		move.l	(sp)+,windowPtr(a6)		MOVE.W	MenuID(A6),D0		; a nifty Pascal case-like macro		CASE#.W	(D0,IF),			\			(AppleMenu,	DoAppleMenu),	\			(FileMenu,	DoFileMenu),	\			(EditMenu,	DoEditMenu),	\			(131,DoAssembleMenu),\			(fenetreMenu, DoFenetreMenu),  \			(137,DEBUG)									; add additional Menus would go here		BRA		Exit			; otherwise we will exit this procedure* ---------- DoAssembleMenu ----------DoAssembleMenu		MOVE.W	MenuItem(A6),D0 		cmp.w	#3,d0		bne		Exit				move.l	#'6305',-(sp)		; mpu type		clr.l	-(sp)				; flags		import	CrossAssemble		jsr		CrossAssemble		bra	Exit* ----------- DEBUG MENU -------------DEBUG		MOVE.W	MenuItem(A6),D0 		cmp.w	#4,d0		bne		Exit				pea		#'liste de sous-titre pointée par a0 et a1 ,Pour redemarrer taper G + ENTER ou command G'		_DebugStr		bra		Exit* ------------- THE APPLE MENU ROUTINES -------------DoAppleMenu		CMPI.W	#AboutItem,MenuItem(A6)	; was it the about item?		BNE.S	@1			; no, must be a Desk Acc		CLR.W	-(SP)			; show the About dialog		MOVE.W	#rAboutAlert,-(SP)	; resource for alert dialog		CLR.L	-(SP)			; no filter procedure used here		_Alert				; read the resource and display it		MOVE.W	(SP)+,D0		; I don't care which item is was		BRA 	Exit			; all done with with Apple menu@1		PEA	TempPort(A6)		; open a desk accessory		_GetPort			; save the current port		CLR.L	-(SP)			; space for result of GetMHandle		MOVE.W	#AppleMenu,-(SP)		_GetMHandle			; put Apple menu on stack		MOVE.W	MenuItem(A6),-(SP)	; and here's the MenuItem		PEA	DeskName(A6)		; now tell me the DA's name		_GetItem		CLR.W	-(SP)			; space for OpenDeskAcc result		PEA	DeskName(A6)		_OpenDeskAcc			; open that puppy		MOVE.W	(SP)+,D0		; result		MOVE.L	TempPort(A6),-(SP)	; restore the port		_SetPort		BRA		Exit		* ------------- THE FILE MENU ROUTINES -------------DoFileMenu			MOVE.W	MenuItem(A6),D0 	; test the MenuItem		Case#.W	(D0,IF),			\			(QuitItem, FileQuit), \			(OpenItem, FileOpen), \			(SaveAsItem, FileSaveAs), \			(SaveItem, FileSave), \			(NewItem, New),\			(PageSetupItem,DoPageSetup),\			(PrintItem,DoImprimer),\			(ExportItem,FileExport)		BRA		Exit			; add additional menus here;DoPageSetup;		jsr	PageSetup		BRA		Exit; ---------------------DoImprimer;		jsr	Imprimer		BRA		Exit; ---------------------FileClose:		CLR.L	-(SP)					_FrontWindow		move.w	#false,-(sp)		_ShowHide		BRA	ExitFileQuit:		move.w	G.ChangeSinceLastSave,d0		and.w	#$7fff,d0		beq.s	EffaceTout_1				; on peut tout effacer car déjà sauvegardé				clr.w	-(sp)		move.w	#152,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		cmp.w	#3,d0		beq		Exit				cmp.w	#2,d0		beq.s	EffaceTout_1; sauvegarde du fichier actuel				clr.w	-(sp)	; pas sauvegarde automatique 		jsr	saveDataEffaceTout_1 				jsr	Terminate		; let's get out of here		BRA	Exit			; Terminate may return if user cancelsFileOpen:		move.w	G.ChangeSinceLastSave,d0		and.w	#$7fff,d0		beq.s	EffaceTout_2				clr.w	-(sp)		move.w	#142,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		cmp.w	#3,d0		beq		Exit				cmp.w	#2,d0		beq.s	EffaceTout_2; sauvegarde du fichier actuel		move.w		#0,-(sp)	;on sauvegarde le fichier en cour 		jsr		    saveDataEffaceTout_2		clr.l	-(sp) ; Selecteur, il n'y a pas de fichier particulier à ouvrir		jsr DoFileOpen		bra	Exit; -----------------------------------------FileSaveAs:		jsr	DoGetSaveName		bra	Exit;--------------------------------------------FileSave:		clr.w	-(sp)	; pas sauvegarde automatique 		jsr	saveData		BRA	Exit;---FileExport		jsr	ExportFichier		BRA	EXIT;----		New:			move.w	G.ChangeSinceLastSave,d0		and.w	#$7fff,d0		beq.s	EffaceTout				; on peut tout effacer car déjà sauvegardé				clr.w	-(sp)		move.w	#142,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		cmp.w	#3,d0		beq		Exit		cmp.w	#2,d0		beq.s	EffaceTout; sauvegarde du fichier actuel		move.w		#0,-(sp)	;on sauvegarde le fichier en cour 		jsr	saveDataEffaceTout		;		clr.w	-(sp)	; document sans titre;		jsr		EffaceTouT						pea		G.listingWindow		_Setport		lea		G.listingWindow,a0		pea		PortRect(a0)		_InvalRect				;		move.w		#2,-(sp)	;on demande un nouveau nom pour le fichier en cour;		jsr		    saveData				bra	Exit* ------------- THE EDIT MENU ROUTINES -------------DoEditMenu			MOVE.W	MenuItem(A6),d0		Case#.W	(D0,IF),			\			(CouperItem,	DoCouper), \			(CopierItem, DoCopier), \			(CollerItem, DoColler),\			(6,SelectAll)		BRA	Exit			; add additional menus here* ------------ select allSelectAll		clr.l	-(sp)		_FrontWindow		move.l	(sp)+,d0		lea		G.ListingWindow,a0		cmp.l	d0,a0		bne.s	PasTEListing		move.l	G.ListingTE,a1		bra.s	DoSelectAllPasTEListing		lea		G.ErrorWindow,a0		cmp.l	d0,a0		bne 	Exit		move.l	G.ErrorTE,a1DoSelectAll				move.l	#0,-(sp)		move.l	#32767,-(sp)		move.l	a1,-(sp)		_TESetSelect		bra	Exit* -------- doUndoDoUndo		bra	Exit* -------- DoCouperDoCouper		lea		G.ListingWindow,a0		cmp.l	WindowPtr(a6),a0		; pour listing ?		beq		listingCut		lea		G.ErrorWindow,a0		cmp.l	WindowPtr(a6),a0		; pour listing ?		beq		errorCut		bra		ExiterrorCut		move.l	G.ErrorTe,a0; on vérifie qu'il y a bien une selection				move.l	(a0),a0	; handle		move.w	TeselEnd(a0),d0		sub.w	TeselStart(a0),d0		ble		Exit		; pas de selection valide, donc on ne change rien						move.l	G.ErrorTe,-(sp)		_TECut					import	TEToScrap		clr.w	-(sp)		jsr	TEToScrap		move.w	(sp)+,d0				move.w	#true,G.ChangeSinceLastSave			bra		Exit;--listingCut				move.l	G.ListingTe,a0; on vérifie qu'il y a bien une selection				move.l	(a0),a0	; handle		move.w	TeselEnd(a0),d0		sub.w	TeselStart(a0),d0		ble		Exit		; pas de selection valide, donc on ne change rien						move.l	G.ListingTe,-(sp)		_TECut			import	TEToScrap		clr.w	-(sp)		jsr	TEToScrap		move.w	(sp)+,d0		move.w	#true,G.ChangeSinceLastSave		bra	Exit* -------- DoCopierDoCopier		lea		G.ListingWindow,a0		cmp.l	WindowPtr(a6),a0		; pour listing ?		beq		listingCopy		lea		G.ErrorWindow,a0		cmp.l	WindowPtr(a6),a0		; pour listing ?		beq		errorCopy		bra		ExiterrorCopy			move.l	G.ErrorTe,a0; on vérifie qu'il y a bien une selection				move.l	(a0),a0	; handle		move.w	TeselEnd(a0),d0		sub.w	TeselStart(a0),d0		ble		Exit		; pas de selection valide, donc on ne change rien						move.l	G.errorTe,-(sp)		_TECopy				import	TEToScrap		clr.w	-(sp)		jsr	TEToScrap		move.w	(sp)+,d0		move.w	#true,G.ChangeSinceLastSave		bra		Exit		; il y t-il un te ?	ListingCopy		move.l	G.ListingTe,a0		cmp.l	#0,a0		beq 	Exit	; non		; on vérifie qu'il y a bien une selection				move.l	(a0),a0	; handle		move.w	TeselEnd(a0),d0		sub.w	TeselStart(a0),d0		ble		Exit		; pas de selection valide, donc on ne change rien						move.l	G.ListingTe,-(sp)		_TECopy				import	TEToScrap		clr.w	-(sp)		jsr	TEToScrap		move.w	(sp)+,d0		move.w	#true,G.ChangeSinceLastSave		bra	Exit		* -------- DoCollerDoColler		lea		G.ListingWindow,a0		cmp.l	WindowPtr(a6),a0		; pour listing ?		beq		listingpaste		lea		G.ErrorWindow,a0		cmp.l	WindowPtr(a6),a0		; pour listing ?		beq		errorpaste		bra		ExiterrorPaste; il y t-il un te ?				move.l	G.errorTe,-(sp)		move.w	#0,-(sp)	; -TEStylPaste		_TEDispatch		move.w	#true,G.ChangeSinceLastSave		bra		Exit		; il y t-il un te ?	listingPaste		move.l	G.ListingTe,a0		cmp.l	#0,a0		beq 	Exit	; non				move.l	a0,-(sp)		move.w	#0,-(sp)	; -TEStylPaste		_TEDispatch		move.w	#true,G.ChangeSinceLastSave		Bra	Exit				; reste de l'ancienne routine;		CLR.W	-(SP)			; system will handle editing of desk accs.;		MOVE.W	MenuItem(A6),-(SP)	; get the MenuItem;		SUBQ.W	#1,(SP)			; SystemEdit is off by one;		_SysEdit;		MOVE.B	(SP)+,D0		; drop result from SystemEdit;		BRA		Exit			; we don't have anything to editDoFenetreMenu:		MOVE.W	MenuItem(A6),D0 	; test the MenuItem		Case#.W	(D0,IF), \		(SaisieItemMenu, DoSaisieMenu), \		(ListingItemMenu, DoListingMenu)		bra		ExitDoSaisieMenu:; hauteur = 100	; on rend la fenètre visible , s'il est n'est pas déja				pea		G.ErrorWindow		move.w	#true,-(sp)		_ShowHide		pea	G.errorWindow		_SelectWindow		bra		Exit		DoListingMenu:		pea		G.ListingWindow		move.w	#true,-(sp)		_ShowHide		pea		G.ListingWindow		_SelectWindow		bra	Exit		Exit	CLR.W	-(SP)			_HiLiteMenu			; unhilite all Menus		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the callertextBuff	DS.B	256textBuff2	ds.b	256		DbgInfo.New	DoMenuCm		; this name will appear in the debugger		align 4			ENDP	* ================================================* PROCEDURE DoMouseDown(Event: EventRecord);* ================================================* Handle all of the MouseDown events.		SEG	'Main'			; case sensitiveDoMouseDown	PROCStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointEventPtr 	DS.L	1	 		; pointer to current eventParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkWindowPtr	DS.L	1			; local Window pointer variableWhere		DS.L	1			; local variable where the click waswhere2		ds.l	1			; 2ème case à pointInWhatPart	ds.W	1			; sauvegarde de findwindowWichControl	DS.L	1			; control en cour de traitementNewGrowRect	DS	Rect			; local rect variable for SizeWindowmodify		ds.w	1MouseMvdRgn	DS.L	1itemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		ds	rect		; rectangleVisRect			ds		RectNewGrowRectinutil	DS	Rect			; local rect variable for SizeWindowtextbuff	ds.b	256textbuff2	ds.b	256	region		ds.l	1DernierSTPointe	ds.w	1LimitRect	ds	RECTSlopRect	ds	rectrectangle	ds	recthandleTE		ds.l	1MPU			ds.w	1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	AdjustMenus,Terminate,DoGrowWindow,DoZoomWindow, \				SelectWindow,ControlActionProc						WITH	StackFrame 		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				movem.l	d0-d7/a0-a3,-(sp)	; sauvegarde des registres		_PenNormal				MOVEA.L	EventPtr(A6),A0		; event record only needed by SystemClick		MOVE.L	evtMouse(A0),Where(A6)	; make a local copy of the mouse location		move.w	evtMeta(a0),modify(a6)		CLR.W	-(SP)			; space for FindWindow result		MOVE.L	Where(A6),-(SP)		; the mouse point		PEA		WindowPtr(A6)		; a local variable		_FindWindow			; put the result in a register		MOVE.W	(SP)+,D0		; a nifty Pascal case-like macro		move.w	d0,InWhatPart(a6)		Case#.W	(D0,IF),			\			(InMenuBar,	MenuEvent),	\			(InSysWindow,SystemEvent),	\			(InContent,	Content),	\			(InDrag,Drag), \			(InGoAway, onsortdela), \			(InGrow, GrowEvent), \			(inZoomIn,ZoomEvent), \			(inZoomOut,ZoomEvent)					BRA	Exit			; otherwise we will exit this procedure		* -----------  Fonctions pour changer la taille de la fenètre ----------* fonction pour changer la taille de la fenètre brutalement à partir de l'icon* zoom window de la fenètre.		string pascalZoomEvent:				move.l	WindowPtr(a6),-(sp)		move.l	Where(a6),-(sp)		move.w	InWhatPart(a6),-(sp)		jsr		DoZoomWindow		move.l	WindowPtr(a6),-(sp)		_setPort		move.l	WindowPtr(a6),a0		pea		PortRect(a0)		_InvalRect					bra 	Exit* fonction pour changer la taiile de la fenètre en fct du grow iconGrowEvent:			lea		MaxSizeof(pc),a0		GEventRoutine				clr.l	-(sp)		move.l	WindowPtr(a6),-(sp)		move.l	a0,-(sp)				MOVE.L	Where(A6),-(SP)			jsr		DoGrowWindow		move.l	WindowPtr(a6),-(sp)		_setPort		move.l	WindowPtr(a6),a0		pea		PortRect(a0)		_InvalRect					bra		Exit; taille minimum et maximum de la fenètre MaxSizeof	dc.w	50	;minHeight	dc.w	50	;minWidth	dc.w	1152	;maxHeight	dc.w	852	;maxwidht* ------------ Fermeture de la fenètre ------------onsortdela:		CLR.W	-(SP)		move.l	WindowPtr(a6),-(sp)		MOVE.L	Where(A6),-(SP)		_TrackGoAway		; a t'on relacher la souris 		move.w	(sp)+,d0	; dans la boite de fermeture ?		beq 	Exit	; non donc on ne ferme pas la fenètre .; on rend la fenètre invisible		move.l	WindowPtr(a6),-(sp)		move.w	#false,-(sp)		_ShowHide		; on rend la fenètre invisible				CLR.L	-(SP)			 		_FrontWindow			 		_SelectWindow	; on active la suivante				CLR.L	-(SP)			 		_FrontWindow			; pass the current window pointer		MOVE.W	#True,-(SP)		; set up for an Activate event		jsr	DoActivate			; do the activate routine		bra	 	Exit	* ------------- THE DESK ACCS EVENT -------------MenuEvent			jsr 	AdjustMenus		CLR.L	-(SP)			; space for MenuSelect		MOVE.L	Where(A6),-(SP)		; Mouse coordinates		_MenuSelect			; pass MenuSelect's result				import	DoMenuCommand		jSR		DoMenuCommand		; go do the menu and return		BRA		Exit* ------------- THE DESK ACCS EVENT -------------SystemEvent	; on vérouille le truc		 		MOVE.L	EventPtr(A6),-(SP)	; get EventRecord and WindowPtr		MOVE.L	WindowPtr(A6),-(SP)	; pass the window pointer and...		_SystemClick			; let the system handle it		BRA 	Exit* ------------- THE CONTENT EVENT -------------Content 				move.l	WindowPtr(a6),-(sp)		_SetPort				clr.l	-(sp)		_FrontWindow		move.l	(sp)+,a0		cmp.l	WindowPtr(a6),a0 		bne		justselectwindow		; pas la fenètre active		; on place le handle du te dans la case tehandle(a6)			lea		G.ListingWindow,a0		cmp.l	WindowPtr(a6),a0		bne.s	PasListing		move.l	G.listingTE,a0		move.l	a0,handleTE(a6)PasListing				lea		G.ErrorWindow,a0		cmp.l	WindowPtr(a6),a0		bne.s	PasError		move.l	G.ErrorTE,a0		move.l	a0,handleTE(a6)PasError				; on convertie les coordonnées en 'local'		pea		Where(a6)		_GlobalToLocal				clr.w	-(sp)   ; parametre en retour		move.l	Where(a6),-(sp)					MOVE.L	WindowPtr(A6),-(SP)			pea		WichControl(a6)		_FindControl		move.w	(sp)+,d0		cmp.w	#inThumb,d0		beq.s	DoControlThumb		tst.w	d0		bne		DoControl		;=> click dans te Rect		move.l	where(a6),-(sp)		move.w	modify(a6),d0		AND.w	#512,d0		beq.s	pasExtend				move.w	#true,-(sp)		bra.s	OuiClickDansTe pasExtend		clr.w	-(sp)		OuiClickDansTe 		move.l	handleTE(a6),-(sp)		_TEClick; on actualise le control de la fenètre		move.l	handleTE(a6),a0		move.l	(a0),a0				; handle		move.w	TeNlines(a0),d7		; on recherche dans quelle ligne se trouve le curseur				move.w	TeSelEnd(a0),d0; on recherche dans la table quel est le n°			move.l	handleTE(a6),a2		adda.l	#4,a2				; vscroll 		move.l	d7,d6			subq.w	#1,d6listingLoop		move.w	d6,d5		lsl.l	#1,d5	; *2		cmp.w	teLines(a0,d5.w),d0		dBhi	d6,listingLoopFoundNum				add.w	#1,d6			move.l	a2,-(sp)		move.w	d7,-(sp)		_SetMaxCtl		move.l	a2,-(sp)		move.w	d6,-(sp)		_SetCtlValue				bra		Exit; ----------------------------------; gestion du control de la fenètre; ----------------------------------DoControlThumb		clr.l	-(sp)		move.l	WichControl(a6),-(sp)		_GetCRefCon		move.l	(sp)+,d0		cmp.l	#1,d7				clr.w	-(sp)   ; parametre en retour		move.l	WichControl(a6),-(sp)		move.l	Where(a6),-(sp)		clr.l	-(sp)		_TrackControl		move.w	(sp)+,d0		beq		Exit		; on ne fait rien		; on calcule la position du texte à montrer		; on regarde si c'est un v scroll 		clr.l	-(sp)		move.l	WichControl(a6),-(sp)		_GetCRefCon		move.l	(sp)+,d0		cmp.l	#1,d0		bne.s	PasHControl						clr.w	-(sp)		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0				move.l	handleTE(a6),a0		move.l	(a0),a0				; handle		move.w	teLineHite(a0),d1		mulu	d1,d0		neg.w	d0				move.w	#0,-(sp)		move.w	d0,-(sp)		move.l	handleTE(a6),-(sp)		_TEPinScroll		bra		Exit		PasHControl				clr.w	-(sp)		move.l	WichControl(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		neg.w	d0				move.w	d0,-(sp)		move.w	#0,-(sp)		move.l	handleTE(a6),-(sp)		_TEPinScroll		BRA	Exit; ----------- not in thumbDoControl		clr.w	-(sp)   ; parametre en retour		move.l	WichControl(a6),-(sp)		move.l	Where(a6),-(sp)		pea		ControlActionProc(pc)		_TrackControl		move.w	(sp)+,d0		BRA	Exit																		* ------ JUST SELECT WINDOW  --------	justselectwindow:				MOVE.L	WindowPtr(A6),-(SP)	; only select this window		jsr		SelectWindow		;	on appelle la fonctionde selection		BRA 	Exit* ------------- THE DRAG A WINDOW EVENT -------------Drag				MOVE.L	WindowPtr(A6),-(SP)	; pass Window Pointer		MOVE.L	Where(A6),-(SP)		; Mouse coordinates and boundary		PEA	QD.Screenbits.bounds			_DragWindow			; drag it the screen's boundary* ----------  SORTIE de la routine -------------------Exit	movem.l	(sp)+,d0-d7/a0-a3			UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	MouseDwn		; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE DoEvent(event: EventRecord);* ================================================* Do the right thing for an event. Determine what kind of event it is,* and call the appropriate routines.		SEG	'Main'			; case sensitiveDoEvent		PROCModifyReg	EQU	D4			; we'll use this register locallyStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start listing parameters hereEventPtr 	DS.L	1	 		; pointer to current eventParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkWindowPtr	DS.l	1			; place pour le VARWindowPtrWhere		DS.l	1			; place pour les coordonnées de la souris			;TheEvent 	DS	EventRecord 		; local copy of the event recordFrontmostWindowPtr	ds.l	1WichControl	DS.L	1			; control en cour de traitementTheDialogSel ds.l	1			; le dialog en questionTheItemHit	ds.w	1			; le item frappéLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	DoMouseDown,	\				AdjustMenus,IsAppWindow,\				DoUpdate,DoActivate,SelectWindow										WITH	StackFrame,TheEvent	; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVEM.L	ModifyReg,-(SP)		; save this register before using it		clr.l	-(sp)		_FrontWindow		move.l	(sp)+,WindowPtr(a6)		MOVEA.L	EventPtr(A6),A0		; pointer of event passed by caller		LEA	TheEvent(A6),A1		; pointer to local variable TheEvent		MOVE.L	#evtBlkSize,D0		; size of an event record		_BlockMove			; we now have a local copy of the event				MOVE.W	Modify(A6),ModifyReg	; a nifty Pascal case-like macro		MOVE.W	What(A6),D0		; get the event number		Case#	(D0,Exit),	\	; if not an event we support, then exit			,		\	;  0 Null (not used)			MouseDown,	\	;  1 Mouse down			,		\	;  2 Mouse up ; pour le control			KeyDown,	\	;  3 Key down			,		\	;  4 Key up (not used)			PasPourMenu,	\	;  5 Auto key			Update, 	\	;  6 Update			Disk,		\	;  7 Disk inserted			Activate,	\	;  8 Activate/Deace/Deactivate			,		\	;  9 (not used)			,		\	; 10 Network (not used)			,		\	; 11 I/O Driver (not used)			,		\	; 12 App1 (not used)			,		\	; 13 App2 (not used)			,		\	; 14 App3 (not used)			OSEvent,		; 15 OS Event or Suspend/Resume* ------------- THE MOUSEDOWN EVENT -------------MouseDown			PEA	TheEvent(A6)		; pass Event pointer in case of SystemClick		jsr	DoMouseDown		BRA	Exit* ------------- THE KEYDOWN EVENT -------------KeyDown					BTST	#CmdKey,ModifyReg	; command key?		BEQ		PasPourMenu 		; no, then we're done		MOVE.W	2+Message(A6),d0		jsr		AdjustMenus		; first, adjust the menus		CLR.L	-(SP)			; space for MenuKey		MOVE.W	2+Message(A6),-(SP)	; get the character		_MenuKey			; is it a command?				move.l	(sp)+,d0		beq.s	PasPourMenu	; pas une commande de menu 		move.l	d0,-(sp)		jsr	DoMenuCommand		; handle the command and return		BRA		ExitPasPourMenu:; on regarde s'il y s'agit de la fenètre listing				lea		G.listingWindow,a0		cmp.l	WindowPtr(a6),a0		beq		listing				; on regarde s'il y s'agit de la fenètre error		lea		G.ErrorWindow,a0		cmp.l	WindowPtr(a6),a0		bne		Exit		; non pas saisie 	Error		; peut ètre une fonction du clavier étendu (en key code)		move.l	Message(a6),d0		lsR.L	#8,d0		and.l	#$ff,d0 		case#.b	(d0,if), \		(121,Error_PPM_FairePlusPage), \		(116,Error_PPM_FaireMinusPage), \		(115,Error_PPM_top), \		(119,Error_PPM_bottom)	; non rien de tous cela 					move.l	Message(a6),D0		and.l	#$ff,d0		MOVE.w	D0,-(sp)		cmp.w	#9,d0			;tab		bne.S	Not_Taberror			move.w	#' ',-(sp)		move.l	G.ErrorTe,-(sp)		_TEKey		move.w	#' ',-(sp)		move.l	G.ErrorTe,-(sp)		_TEKey		move.w	#' ',-(sp)		move.l	G.ErrorTe,-(sp)		_TEKey		move.w	#' ',-(sp)Not_TabError					move.l	G.ErrorTe,-(sp)		_TEKeyError_CalcControl		; on actualise le control de la fenètre		move.l	G.ErrorTe,a0		move.l	(a0),a0		move.w	TeNlines(a0),d7		; on recherche dans quelle ligne se trouve le curseur				move.w	TeSelEnd(a0),d0; on recherche dans la table quel est le n°					move.l	d7,d6			subq.w	#1,d6errorLoop		move.w	d6,d5		lsl.l	#1,d5	; *2		cmp.w	teLines(a0,d5.w),d0		dBhi	d6,errorLoopFoundNum				add.w	#1,d6			move.l	G.ErrorVscroll,-(sp)		move.w	d7,-(sp)		_SetMaxCtl		move.l	G.ErrorVscroll,-(sp)		move.w	d6,-(sp)		_SetCtlValue		move.w	#true,G.ChangeSinceLastSave					bra		Exit		Error_PPM_FaireMinusPage:		lea.l	G.ErrorWindow,a0		Move.w	bottom+PortRect(a0),d0		sub.w	#16,d0					; hauteur de la fenètre				move.l	G.ErrorTe,a0		move.l	(a0),a0			; handle				move.w	telineHite(a0),d1		moveq	#0,d2		move.l	d0,d2		divu	d1,d2		subq.w	#1,d2		mulu	d1,d2		move.w	#0,-(sp)		neg.w	d2		move.w	d2,-(sp)		move.l	G.ErrorTE,-(sp)		_TEpinScroll						bra	Exit		Error_PPM_FairePlusPage:		lea.l	G.ErrorWindow,a0		Move.w	bottom+PortRect(a0),d0		sub.w	#16,d0					; hauteur de la fenètre				move.l	G.ErrorTE,a0		move.l	(a0),a0			; handle				move.w	telineHite(a0),d1		moveq	#0,d2		move.l	d0,d2		divu	d1,d2		subq.w	#1,d2		mulu	d1,d2				move.w	#0,-(sp)		move.w	d2,-(sp)		move.l	G.ErrorTE,-(sp)		_TEPinScroll						bra	Exit		Error_PPM_top				move.l	0,-(sp)		move.l	0,-(sp)		move.l	G.ErrorTE,-(sp)		_TeSetSelect		bra	Exit		Error_PPM_bottom			move.l	32767,-(sp)		move.l	32767,-(sp)		move.l	G.ErrorTE,-(sp)		_TeSetSelect		bra	Exit	; ----------------------------------------------------------------------listing					; peut ètre une fonction du clavier étendu (en key code)		move.l	Message(a6),d0		lsR.L	#8,d0		and.l	#$ff,d0 		case#.b	(d0,if), \		(121,PPM_FairePlusPage), \		(116,PPM_FaireMinusPage), \		(115,PPM_top), \		(119,PPM_bottom)	; non rien de tous cela 				move.l	Message(a6),D0		and.l	#$ff,d0		cmp.w	#$03,d0		bne.s	@1		move.w	#13,d0@1					MOVE.w	D0,-(sp)		cmp.w	#9,d0			;tab		bne.S	Not_TabListing			move.w	#' ',-(sp)		move.l	G.ListingTe,-(sp)		_TEKey		move.w	#' ',-(sp)		move.l	G.ListingTe,-(sp)		_TEKey		move.w	#' ',-(sp)		move.l	G.ListingTe,-(sp)		_TEKey		move.w	#' ',-(sp)Not_TabListing					move.l	G.ListingTe,-(sp)		_TEKey; on actualise le control de la fenètre		move.l	G.ListingTe,a0		move.l	(a0),a0		move.w	TeNlines(a0),d7		; on recherche dans quelle ligne se trouve le curseur				move.w	TeSelStart(a0),d0; on recherche dans la table quel est le n°					move.l	d7,d6			subq.w	#1,d6Listing_Loop		move.w	d6,d5		lsl.w	#1,d5	; *2		move.w	teLines(a0,d5.w),d1		cmp.w	d1,d0		dBhi	d6,Listing_Looplisting_FoundNum				add.w	#1,d6			move.l	G.ListingVscroll,-(sp)		move.w	d7,-(sp)		_SetMaxCtl		move.l	G.ListingVscroll,-(sp)		move.w	d6,-(sp)		_SetCtlValue		move.w	#true,G.ChangeSinceLastSave					bra		Exit		PPM_FaireMinusPage:		lea.l	G.listingWindow,a0		Move.w	bottom+PortRect(a0),d0		sub.w	#16,d0					; hauteur de la fenètre				move.l	G.ListingTe,a0		move.l	(a0),a0			; handle				move.w	telineHite(a0),d1		moveq	#0,d2		move.l	d0,d2		divu	d1,d2		subq.w	#1,d2		mulu	d1,d2		move.w	#0,-(sp)		neg.w	d2		move.w	d2,-(sp)		move.l	G.listingTE,-(sp)		_TEScroll						bra	Exit		PPM_FairePlusPage:		lea.l	G.listingWindow,a0		Move.w	bottom+PortRect(a0),d0		sub.w	#16,d0					; hauteur de la fenètre				move.l	G.ListingTe,a0		move.l	(a0),a0			; handle				move.w	telineHite(a0),d1		moveq	#0,d2		move.l	d0,d2		divu	d1,d2		subq.w	#1,d2		mulu	d1,d2				move.w	#0,-(sp)		move.w	d2,-(sp)		move.l	G.listingTE,-(sp)		_TEScroll						bra	Exit		PPM_top				move.l	0,-(sp)		move.l	0,-(sp)		move.l	G.listingTE,-(sp)		_TeSetSelect		bra	Exit		PPM_bottom			move.l	32767,-(sp)		move.l	32767,-(sp)		move.l	G.listingTE,-(sp)		_TeSetSelect		bra	Exit		* ------------- THE UPDATE EVENT -------------Update			MOVE.L	Message(A6),-(SP)	; pass the window pointer		jsr	DoUpdate		; do the update		BRA.S	Exit* ------------- THE DISK EVENT -------------Disk			TST.W	Message(A6)		; check for error		BEQ.S	@1			; if none, skip		CLR.W	-(SP)		MOVE.L	#DITopLeft,-(SP)		MOVE.L	Message(A6),-(SP)		MOVE.W	#diBadMount,-(SP)		_Pack2				; go through disk init package		ADDQ	#2,SP			; throw away result@1		BRA.S	Exit* ------------- THE ACTIVATE/DEACTIVATE EVENT -------------Activate		BTST	#ActiveFlag,ModifyReg	; was it an Activate?		BEQ.S	@1			; no, perform a Deactivate		MOVE.L	Message(A6),-(SP)	; pass the current window pointer		MOVE.W	#True,-(SP)		; set up for an Activate event		jsr	DoActivate		; do the activate routine		BRA.S	Exit			; we're done@1		MOVE.L	Message(A6),-(SP)	; pass current window pointer		MOVE.W	#False,-(SP)		; set up for an Deactivate event		jsr	DoActivate		; go do the activate routine		BRA.S	Exit			; we're done* ------------- THE SUSPEND/RESUME EVENT -------------* OSEvent is the event number of the suspend/resume and mouse-moved events sent* by MultiFinder. Once we determine that an event is an osEvent, we look at the* high byte of the message sent to determine which kind it is. To differentiate* suspend and resume events we check the resumeMask bit.OSEvent	 		MOVE.B	Message(A6),D1		; get high byte of Message in reg		CMPI.B	#SuspendResume,D1	; test for message event type		BNE 	Exit			; not a suspend/resume event		BTST	#0,3+Message(A6)	; test bit zero in low byte of Message		BNE.S	@1			; this is a resume event				MOVE.W	#True,G.InBackground	; a suspend event		CLR.L	-(SP)			; bug fix, was passing Message to DoActivate -JDR 2/27/89 		_FrontWindow			; pass the front window to DoActivate -JDR 2/27/89		MOVE.W	#False,-(SP)		; pass false to cause deactivate		jsr	DoActivate		; go do the activate routine		BRA.S	Exit@1		MOVE.W	#False,G.InBackground	; a resume event		CLR.L	-(SP)			; bug fix, was passing Message to DoActivate -JDR 2/27/89 		_FrontWindow			; pass the front window to DoActivate -JDR 2/27/89		MOVE.W	#True,-(SP)		; pass false to cause activate		jsr	DoActivate		; go do the activate routine		Exit				MOVEM.L	(SP)+,ModifyReg		; restore this register after use		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	DoEvent			; this name will appear in the debugger		align 4			ENDP		; --------------------------------------------------------------------* ======================================================================*	Fonction	SpecialModalDialog();* ======================================================================** Cette routine configure les touches de fonctions accessibles f1 -15*			SEG 'Traitement'SpecialModalDialog		PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordItemHit		ds.w	1ParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	ds.L	1			; place holder for return addressA6Link		ds.L	1			; place holder for A6 linkitemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds 		RecttheDialog	ds.l	1Rectangle	ds		RectTheEvent 	DS		EventRecord 		; local copy of the event recordMouseMvdRgn	DS.L	1			; local region for MouseMoved eventsMousePos	DS.L	1			; local point for mouse positionMouseLoc	ds.l	1			; point de la sourisWindowPtr	ds.l	1Where		ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	WaitTicks,DoMenuCommand, \				AdjustMenus,AdjustCursor,GetGlobalMouse		WITH	StackFrame,TheEvent,AppGlobals			; cover our local stack frame				link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(SP)				CLR.L	-(SP)		_NewRgn				; create region for AdjustCursor		MOVE.L	(SP)+,MouseMvdRgn(A6)	; save the handle to this region		MOVE.L	MouseMvdRgn(A6),-(sp)			_SetEmptyRgn* ------------- GET NEXT EVENT LOOP -------------NextEvent			CMPI.W	#True,G.HasWNEvent 	; see if we can call WaitNextEvent		BNE.S	@1			; nope, old time events				PEA	MousePos(A6)		; here's the mouse		jsr	GetGlobalMouse		; get global coordinate		 		CLR.W	-(SP)			; space for result		MOVE.W	#EveryEvent,-(SP)	; the events we want		PEA		TheEvent(A6)		; pointer to the event record		MOVE.L	#SleepValue,-(SP)	; the sleeping time value		MOVE.L	MouseMvdRgn(A6),-(SP)	; the current MouseRgn		_WaitNextEvent		BRA.S	@2			; got an event to handle?	; no WaitNextEvent trap available@1		_SystemTask			; call SystemTask for drivers and DAs		CLR.W	-(SP)			; space for result		MOVE.W	#EveryEvent,-(SP)	; the events we want		PEA	TheEvent(A6)		; pass a pointer to our event		_GetNextEvent@2		MOVE.W	(SP)+,D0		; result code;		BEQ.S	NextEvent		; no event, get another one		GotEvent			; ¢a y est nous avons un événement; move window	?		MOVE.W	TheEvent.What(A6),D0				; get the event number		cmp.w	#1,d0					; Mouse down ?		beq 	MoveWindow		cmp.w	#6,d0					;Update		beq		Update		cmp.w	#3,d0					; key down		beq		KEYdOWN		cmp.w	#5,d0					; repeatkey down		beq		KEYdOWN		bra		PasMoveWindow; -------KEYdOWN		move.l	theEvent.Message(a6),d0		and.l	#$ff,d0		case#.w	(d0,if),\		(13,Enter_1),\		(3,Enter_1),\		(30,up_1),\		(31,down_1),\		(28,left_1),\		(29,right_1)		bra		NextEvent	; on reboucleEnter_1			move.w	#1,ItemHit(a6)				clr.l	-(sp)				_FrontWindow		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDitem				move.l	ItemHandle(a6),-(sp)		move.w	#1,-(sp)		_HiliteControl				move.l	#4,-(sp)		import	WaiTaicks		jsr		WaiTaicks				move.l	ItemHandle(a6),-(sp)		move.w	#0,-(sp)		_HiliteControl						bra		exit	; on reboucle; up_1		clr.l	-(sp)				_FrontWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal		sub.w	#1,top+Rectangle(a6)		move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		bra		NextEvent	; on reboucle; -------down_1		clr.l	-(sp)				_FrontWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal		add.w	#1,top+Rectangle(a6)		move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		bra		NextEvent	; on reboucle; -------left_1		clr.l	-(sp)				_FrontWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal		sub.w	#1,left+Rectangle(a6)		move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		bra		NextEvent	; on reboucle; -------right_1				clr.l	-(sp)				_FrontWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal		add.w	#1,left+Rectangle(a6)		move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		bra		NextEvent	; on reboucle; -------		; peut ètre un update window pour les autre fenètresUpdate				clr.l	-(sp)				_FrontWindow		move.l	(sp)+,d0		cmp.L	theEvent.Message(a6),d0		beq		PasMoveWindow			; pour le dialog en cour; oui pour les autres fenètres du programme				MOVE.L	theEvent.Message(a6),-(SP)	; pass the window pointer		jsr		DoUpdate				; do the update		bra		PasMoveWindow		;  mouse window ?MoveWindow			CLR.W	-(SP)						; space for FindWindow result		MOVE.L	TheEvent.where(A6),-(sp)		; the mouse point		PEA		WindowPtr(A6)				; a local variable		_FindWindow							; put the result in a register		MOVE.W	(SP)+,D7				clr.l	-(sp)				_FrontWindow		move.l	(sp)+,d0		cmp.l	WindowPtr(A6),d0		bne.s	beep	; on reboucle		case#.w	(d7,if),\; a nifty Pascal case-like macro		(InDrag,MoveWindow_1),\		(inContent,PasMoveWindow)beep				move.w	#10,-(sp)		_SysBeep		bra		NextEvent	; on reboucle		MoveWindow_1; pass Window Pointer		move.l	WindowPtr(A6),-(sp)		MOVE.L	TheEvent.where(A6),-(sp)		; Mouse coordinates and boundary		PEA		QD.ScreenBits.bounds			_DragWindow								; drag it the screen's boundary		bra		NextEvent	; on reboucle;----PasMoveWindow		clr.w	-(sp)		pea		TheEvent(A6)		_IsDialogEvent		move.w	(sp)+,d0		beq		NextEvent	; on reboucle; 	PasMoveWindow_1		clr.w	-(sp)		pea		TheEvent(A6)		pea		theDialog(a6)		pea		itemHit(a6)		_dialogSelect		move.w	(sp)+,d0		bne 	Exit		bra		NextEvent	; on reboucleEXIT	MOVE.L	MouseMvdRgn(A6),-(sp)			_DisposRgn		movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New			SpecialModalDialog 		endp	* ================================================* --------------- MAIN ENTRY POINT ---------------* ================================================* This is the entry point of the program.  We start with data initializing* and then to get the System environment (SysEnvirons).  We unload the* initialization code segment and finally get started with the EventLoop.		SEG	'Main'			; case sensitiveStartUp        	MAIN				; entry point of the program				IMPORT	_DataInit,Initialize,	\			ForceEnvirons,EventLoop			JSR	_DataInit		; initialize those constants			PEA	_DataInit		; get rid of that segment		_UnloadSeg* If you have stack requirements that differ from the default, then you could* use SetApplLimit to increase StackSpace at this point, before calling MaxApplZone.		_MaxApplZone			; result in D0		JSR	Initialize		; get things the program set up		PEA	Initialize		_UnloadSeg			; we're done this that segment too		* on fera le test d'ouverture automatique de fichier, ou et d'impression			LEA	EventLoop,A0		; on your mark, get set,...		JMP	(A0)			; go into the event loop		align 4			ENDP* ================================================* PROCEDURE EventLoop;* ================================================* Get the events by calling WaitNextEvent, if it's available, otherwise* by calling GetNextEvent. Also call AdjustCursor before doing the event.* After returning from handling the event, we have to make sure the cursor* is still adjusted proper ONLY because this application can "sleep" forever.* An event record is allocated on the stack.  A pointer to this event is* passed to "DoEvent".  We loop until the user has selects "Quit" in the* file menu.  This program will exit through the DoMenuCommand routine.* 1.02 made adjustments to the event loop logic.  There was a bug in calling* AdjustCursor at the wrong time. (it crashed under _GetNextEvent too!)* If you are using modeless dialogs that have editTems,* you will want to call IsDialogEvent to give the caret a chance* to blink, even if WNE/GNE returned FALSE. However, check FrontWindow* for a non-NIL value before calling IsDialogEvent.		SEG	'Main'			; case sensitiveEventLoop	PROC	Export		; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start listing parameters hereParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTheEvent 	DS	EventRecord 		; local copy of the event recordMouseMvdRgn	DS.L	1			; local region for MouseMoved eventsMousePos	DS.L	1			; local point for mouse positionRectfenetre	DS 	rect			; de la fenètreMouseLoc	ds.l	1			; point de la sourisbuffer		ds.b	128itemType	ds.w	1			; stockage du type de ItemitemHandle	ds.L	1			; stockage	du handle du itemitemRect	ds		Rect		; rectangleVisRect		ds	RectIconHandle	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	AdjustCursor,GetGlobalMouse,DoEvent		WITH	StackFrame 	; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				CLR.L	-(SP)		_NewRgn				; create region for AdjustCursor		MOVE.L	(SP)+,MouseMvdRgn(A6)	; save the handle to this region		* ------------- GET NEXT EVENT LOOP -------------NextEvent			CMPI.W	#True,G.HasWNEvent 	; see if we can call WaitNextEvent		BNE.S	@1			; nope, old time events				PEA	MousePos(A6)		; here's the mouse		jsr	GetGlobalMouse		; get global coordinate		MOVE.L	MousePos(A6),-(SP)	; here's the mouse		MOVE.L	MouseMvdRgn(A6),-(SP)	; the region to change		jsr	AdjustCursor		; adjust the cursor and region		CLR.W	-(SP)			; space for result		MOVE.W	#EveryEvent,-(SP)	; the events we want		PEA	TheEvent(A6)		; pointer to the event record		MOVE.L	#SleepValue,-(SP)	; the sleeping time value		MOVE.L	MouseMvdRgn(A6),-(SP)	; the current MouseRgn		_WaitNextEvent		BRA.S	@2			; got an event to handle?							; no WaitNextEvent trap available@1		_SystemTask			; call SystemTask for drivers and DAs		CLR.W	-(SP)			; space for result		MOVE.W	#EveryEvent,-(SP)	; the events we want		PEA	TheEvent(A6)		; pass a pointer to our event		_GetNextEvent@2		MOVE.W	(SP)+,D0		; result code;		BEQ.S	NextEvent		; no event, get another one		GotEvent	MOVE.L	TheEvent.where(A6),-(SP); the mouse location		MOVE.L	MouseMvdRgn(A6),-(SP)	; the region to change		jsr	AdjustCursor		; adjust cursor BEFORE doing event						move.l	G.ErrorTE,-(sp)		_TeIdle		move.l	G.ListingTE,-(sp)		_TeIdle				PEA	TheEvent(A6)		; pass the pointer to our event		jsr	DoEvent			; do the event and return		BRA.S	NextEvent		; done with that event, get the nextExit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	EvntLoop		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE DoFileOpen():* ================================================		SEG	'Main'			; case sensitiveDoFileOpen	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointFinderMessage		DS.L	1			; passed reference to mouse positionParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkreply		ds		StandardFileReplyparamBlock	ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierfsOpenErr	ds.w	1fsRefNum	ds.w	1seconds		ds.l	1Buffer		ds.l	1count		ds.l	1FileLenth	ds.l	1DialogStorage	ds	dWindLenLocalSize	EQU 	*			; size of all the local variables		ENDR; LE FAit de déclarer reply dans With,; fait que reply devient un offset utilisable pour cette procedure; comme reply est un record on peut utiliser les offsets défini dans ce record,`; par example : sfGood(a6) équivalent à   Reply+sfGood(a6)		WITH	StackFrame,reply 	; cover our local stack frame		import	TraitementErreurFichier,CopyStr,AppendStr				LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d1-d7/a1-a4,-(sp)					; on regarde si nous avons un fichier particulier à lire		move.l	FinderMessage(a6),a4		cmp.l	#0,a4		bne.s	IlYaUnMessage; --------------------------------------		clr.l	-(sp) ; file filter = none		Move.w	#2,-(sp)		; on veut les  fichiers bon_bougre		pea		TYPELYST(pc)		Pea		reply(a6)		_StandardGetFile		move.l	sfsparID(a6),G.CurrentDirID		move.w	sfsvRefNum(a6),G.CurrentvRefNum		move.l	sfType(a6),G.CurrentFileType		lea		sfsname(a6),a0		lea		G.CurrentFileName,a1		bsr		CopyStr	; ON RECOPIE LE NOM DU FICHIER EN COURS		move.b	sfGood(a6),d0		bEQ		Exit	; l'utilisateur à Cancelé		bra 	OuvrirLeFichier; ------------------------------------------------IlYaUnMessage		; on recopie les infos données par le finder		move.w	(a4),G.CurrentvRefNum		move.w	(a4),sfsvRefNum(a6)		move.l	2(a4),G.CurrentFileType		move.l	2(a4),sfType(a6)		move.b	6(a4),G.CurrentVersionNumber		lea		8(a4),a0		lea		G.CurrentFileName,a1		bsr		CopyStr	; ON RECOPIE LE NOM DU FICHIER EN COURS		lea		8(a4),a0		lea		sfsname(a6),a1		bsr		CopyStr	; ON RECOPIE LE NOM DU FICHIER EN COURS; on ouvre le fichier				lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		lea		G.CurrentFileName,a1		move.l	a1,ioNamePtr(a0)		move.w	G.CurrentvRefNum,ioVrefNum(a0)		move.b	G.CurrentVersionNumber,26(a0)		move.b	#4,ioPermssn(a0)			_SetVol	; pour ètre sur du directory				lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.b	#4,ioPermssn(a0)			;fsRWrShPerm			clr.l	ioOwnBuf(a0)			_Open		jsr		TraitementErreurFichier			tst.l	d1		beq		OpenFile_Suite		move.l	#-1,d0		bra		Exit		; ------------------------	; ON TENTE D'OUVRIR LE FICHIER désigné OuvrirLeFichier			lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.b	#4,ioPermssn(a0)			;fsRWrShPerm			clr.l	ioOwnBuf(a0)		move.l	sfsparID(a6),ioDirID(a0)		_HOpen		jsr		TraitementErreurFichier			tst.l	d1		beq		OpenFile_Suite		move.l	#-1,d0		bra	Exit; on recherche le eof du fichier; pour connaitre la longueur du fichierOpenFile_Suite				lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		_GetEOF		jsr		TraitementErreurFichier		lea.l	paramBlock(a6),a0		move.l	ioLEOF(a0),FileLenth(a6)		; on effectue un aiguillage en fct de type de fichier		move.l	sfType(a6),d0		case#.l	(d0,if),\		('TEXT', DoTexte),\		(' bin', DoRomImage)				; pas fichier bon bougre		clr.w	-(sp)		move.w	#143,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		cmp.w	#1,d0		bne.s	HaveAlook		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_Close				move.w	#false,G.ChangeSinceLastSave			move.l	#-1,d0		bra	Exit* ------------------------------------------------HaveAlook		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.l	G.BufferTexte,ioBuffer(a0)		move.l	G.Text_HIMEM,d0		sub.l	G.BufferTexte,d0		move.l	d0,ioReqCount(a0)		move.w	#fsFromStart,ioPosMode(a0)		clr.l	ioPosOffset(a0)		_Read		jsr		TraitementErreurFichier		tst.l	d1		bne		CLOSEFILE		move.l	G.BufferTransfert,a0		move.l	G.SIZEBufferTransfert,d1		break		bra		CLOSEFILE* ***********************************************		; lecture du fichier sourceDoTexte			lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.l	G.BufferTexte,ioBuffer(a0)		move.l	G.Text_HIMEM,d0		sub.l	G.BufferTexte,d0		move.l	d0,ioReqCount(a0)		move.w	#fsFromStart,ioPosMode(a0)		clr.l	ioPosOffset(a0)		_Read				jsr		TraitementErreurFichier		tst.l	d1		bne		CLOSEFILE;		lea		paramBlock(a6),a0		move.l	G.BufferTexte,-(sp)		move.l	ioActCount(a0),d0		cmp.l	#32768,d0		blo.s	@1		move.l	#32767,d0@1				move.l	d0,-(sp)		move.l	G.ListingTE,-(sp)		_TeSetText; on recopie le coordonées du fichier en mémoire; on regarde s'il faut disposer le handle		move.l	G.AliasHandle,d0		beq.s	PasDeHandle		move.l	d0,a0		_DisposHandle		clr.l	G.AliasHandlePasDeHandle; on créer un alias manager pour le fichier en cour		clr.w	-(sp)	; space pour return		clr.l	-(sp)	; no from file search		pea		6+reply(a6)			; FSS Spec		pea		G.AliasHandle		; adresse de sauvegarde du handle		_NewAlias		move.w	(sp)+,d0		; on raz le chien de garde pour sauvegarde automatique		clr.l	-(sp)		_TickCount		move.l	(sp)+,G.WatchDogSave; on indique que le fichier est vierge de modification				clr.w	G.ChangeSinceLastSave		finLecture		clr.w	G.ChangeSinceLastSave		bra		CLOSEFILE* ***********************************************		; lecture du fichier (format maison !) (hi !)DoRomImageOk_PasDeProblemeOnEfface				pea	paramBlock(a6)		pea	sfsname(a6)		move.l	FileLenth(a6),-(sp); lecture de l'image rom; ----------------------------------------------------				; ----------------------------------------------------		bra		finLecture* ***********************************************; ON FERME LE FICHIERCLOSEFILE		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_Close		jsr		TraitementErreurFichier		moveq	#0,d0Exit	pea		G.listingWindow		_Setport		lea		G.listingWindow,a0		pea		PortRect(a0)		_InvalRect				; on place les noms dans les fenètres										lea		errorName(pc),a0		lea		buffer(a6),a1		jsr		CopyStr						lea		G.CurrentFileName,a0		lea		buffer(a6),a1		jsr		AppendStr			pea		G.errorWindow		Pea		buffer(a6)		_SetWtitle					lea		ListingName(pc),a0		lea		buffer(a6),a1		jsr		CopyStr						lea		G.CurrentFileName,a0		lea		buffer(a6),a1		jsr		AppendStr			pea		G.ListingWindow		Pea		buffer(a6)		_SetWtitle				;; on actualise le control de la fenètre		move.l	G.listingTe,a0		move.l	(a0),a0		move.w	TeNlines(a0),d7		; on recherche dans quelle ligne se trouve le curseur				move.w	TeSelEnd(a0),d0; on recherche dans la table quel est le n°					move.l	d7,d6			subq.w	#1,d6listingLoop		move.w	d6,d5		lsl.w	#1,d5	; *2		cmp.w	teLines(a0,d5.w),d0		dBhi	d6,listingLoopFoundNum				add.w	#1,d6			move.l	G.listingVscroll,-(sp)		move.w	d7,-(sp)		_SetMaxCtl		move.l	G.listingVscroll,-(sp)		move.w	d6,-(sp)		_SetCtlValue														movem.l	(sp)+,d1-d7/a1-a4						UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		STRING	ASISTYPELYST	DC.L	'TEXT'		; fichier ascii 			DC.L	' bin'		; fichier romImage		string	PascalerrorName	dc.b	'Erreur : 'ListingName	dc.b	'Source : '		DbgInfo.New	DoFileOpen		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE		DoGetSaveName* ================================================		SEG	'Main'			; case sensitiveDoGetSaveName	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		import	saveData		WITH	StackFrame,StandardFileReply,SFReply		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		clr.l	G.CurrentFileType		clr.w	-(sp)				; pas AutoSave		jsr		saveData				UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	DoGetSaveName		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE		saveData()* ================================================		SEG	'Main'			; case sensitivesaveData	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointflag		ds.w	1				; si true sauvegarde automatiqueParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkDialogStorage	ds	dWindLenreply			ds		StandardFileReplyfssSafeSave		ds.b	70	; fssRecordfsOpenErr		ds.w	1fsRefNum		ds.w	1seconds			ds.l	1Buffer			ds.l	1count			ds.l	1FileLenth		ds.l	1txtbuffer		ds.b	256itemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RectItemchoisi		ds.w	1paramBlock		ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierparamBlockBak	ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierWasChanged		ds.w	1LocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	WaitTicks,CopySTR,AppendSTr,TraitementErreurFichier				WITH	StackFrame,Reply,fssSpec		;cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		; on regarde s'il y a déja un nom et des parramètres pour stocker le fichier	; si oui on sauvegarde directement; on teste le file type ; si NIL ou ≠ 'TEXT' => on demande un nom pour le saveData en Bbof; si = 'TEXT' => sauvegarde avec les parramètres en mémoire		move.l	G.CurrentFileType,d0		cmp.l	#'TEXT',d0		bne		PasNomDeFichierEnCour		; on recopie les paramètres en mémoire dans le paramBlock; on effectue une recherche par le alias manager du fichier en cour				clr.w	-(sp)		clr.l	-(sp)		; pas de 'from file'		move.l	G.AliasHandle,-(sp)		pea		6+reply(a6)		; FSS record		pea	WasChanged(a6)		_ResolveAlias		move.w	(sp)+,d0			bra		FileExistAlready	;	si non on demande à l'utilisateur son choix pour saveData le nom du fichierPasNomDeFichierEnCour; on regarde si c'est une sauvegarde automatique		cmp.w	#true,flag(a6)		bne.s	PasSauvegardeAutomatique; on indique à l'utilisateur, qu'il n'a pas indiquer de nom pour sauvegarder son documents		CLR.W	-(SP)			 		MOVE.W	#155,-(SP)	 		CLR.L	-(SP)			 		_Alert				 		MOVE.W	(SP)+,D0		 PasSauvegardeAutomatique		clr.l	-(sp) ; file filter = none		Move.w	#1,-(sp); on veut tous les TYPEs de fichiers		pea		TYPELYST(pc)	; format des fichiers de Cross Assemble		Pea		reply(a6)		string Pascal				cmp.w	#2,flag(a6)		; nouveau fichier ?		bne.s	PasNewFichier	; non				pea		#'Nouveau Document :'		bra.s	PasNewFichier_1PasNewFichier				pea		#'Sauvegarder le fichier :'PasNewFichier_1				pea		G.CurrentFileName		Pea		reply(a6)		_StandardPutFile		move.b	sfGood(a6),d0		beq		Exit 	; l'utilisateur à Cancelé				tst.b	sfReplacing(a6)			  		bne		FileExistAlready_1		; le fichier existe déjà; le fichier n'existe pas	; on commence par créer le fichier en question.		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.l	sfsparID(a6),ioDirID(a0)		_HCreate; maintenant le fichier éxiste 		; on recopie les variables en mémoire		FileExistAlready_1		move.l	#'Bbo1',G.CurrentFileType		; on dit que c'est un fichier Cross Assemble		lea		sfsname(a6),a0		lea		G.CurrentFileName,a1		bsr		CopyStr	; ON RECOPIE LE NOM DU FICHIER EN COURS		; on regarde s'il faut disposer le handle		move.l	G.AliasHandle,d0		beq.s	PasDeHandle		move.l	d0,a0		_DisposHandle		clr.l	G.AliasHandlePasDeHandle; on créer un alias manager pour le fichier en cour		clr.w	-(sp)	; space pour return		clr.l	-(sp)	; no from file search		pea		6+reply(a6)			; FSS Spec		pea		G.AliasHandle		; adresse de sauvegarde du handle		_NewAlias		move.w	(sp)+,d0FileExistAlready; on ouvre le fichier		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.l	sfsparID(a6),ioDirID(a0)		move.b	#4,ioPermssn(a0)			;fsRWrShPerm			clr.l	ioOwnBuf(a0)		_HOpen		jsr		TraitementErreurFichier			tst.l	d1		bne		Exit 			lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		clr.w	28(a0)	;DirIndex		clr.l	ioOwnBuf(a0)		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		_HGetFileInfo		jsr		TraitementErreurFichier	; ---------------------------------------------------------------------------------; OK FICHIER OUVERT , nous pouvons écrire dans le fichier			clr.l	-(sp)		move.l	G.ListingTe,-(sp)		_TeGetText		move.l	(sp)+,a0		move.l	(a0),a4		; textptr=*Charhandle		move.l	G.ListingTe,a0		move.l	(a0),a3		;tePtr=*teHandle		moveq	#0,d0		move.w	teLength(a3),d0		; longueur du texte				lea		paramBlock(a6),a0		move.l	d0,ioReqCount(a0)		move.l	buffer(a6),a1		move.l	a4,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)						_Write		; ---------------------------------------------------------------------------------				move.w	#0,G.ChangeSinceLastSave		; on raz le flag pour dire saveData; on a fini de décrire dans le fichier, on actualise les info du film; on commence par lire les infos: 	; il faut maintenant créer les infos pour le finder		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		move.l	Time,ioFlMdDat(a0)		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		Move.l	#'TEXT',ioFlUsrWds(a0)		; Bbof format de bon bougre		move.l	#'Bbo1',4+ioFlUsrWds(a0)	; Bbou signature application		move.l	sfsparID(a6),ioDirID(a0)		_HSetFileInfo		jsr		TraitementErreurFichier		; on dit au dos de s'assurer que tous à bien été écrit sur le disque; et on affiche un petit message pour dire que nous arrivons tous de suite		clr.l	-(sp)		move.w	#140,-(sp)		pea		DialogStorage(a6)		move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_FlushFile		jsr		TraitementErreurFichier		move.l	#60,-(sp)		bsr		WaitTicks		PEA		DialogStorage(a6)		_CloseDialog; on raz le chien de garde pour sauvegarde automatique		clr.l	-(sp)		_TickCount		move.l	(sp)+,G.WatchDogSavecloseFile			lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_Close	*   --------------------------------------------------------------------Exit	; on place les noms dans les fenètres										lea		errorName(pc),a0		lea		txtbuffer(a6),a1		jsr		CopyStr						lea		G.CurrentFileName,a0		lea		txtbuffer(a6),a1		jsr		AppendStr			pea		G.errorWindow		Pea		txtbuffer(a6)		_SetWtitle					lea		ListingName(pc),a0		lea		txtbuffer(a6),a1		jsr		CopyStr						lea		G.CurrentFileName,a0		lea		txtbuffer(a6),a1		jsr		AppendStr			pea		G.ListingWindow		Pea		txtbuffer(a6)		_SetWtitle		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		STRING	ASISTYPELYST	DC.L	'TEXT'			DC.L	'Bbof'			string	PascalerrorName	dc.b	'Erreur : 'ListingName	dc.b	'Source : '					align 4		DbgInfo.New		saveData		; this name will appear in the debugger		ENDP		* ================================================* PROCEDURE 	TraitementErreurFichier()* ================================================; AFFICHE UNE ALERT POUR INDIQUER LE N° D'ERREUR DE LECTURE SI DIFFÉRENT DE -39 ET 0TraitementErreurFichier		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkBuffer			ds.b	256ItemType 		ds.w	1ItemHandle 		ds.l	1itemRect 		ds		rectTheItemHitalert	ds.w	1LocalSize		EQU 	*					ENDR										WITH	StackFrame,StandardFileReply,SFReply	; on utilise le même stackframe				LINK	A6,#LocalSize		; allocate our local stack frame							TST.W	D0				BEQ		exit2								CMP.W	#-39,D0				beq		exit2												LEA		BUFFER(A6),A0				CLR.W	-(SP)				_PACK7								; ON OUVRE UN DIALOG POUR DIRE À L'UTILISATEUR QU'IL Y A EU UNE ERREUR			move.w	#137,-(sp)			pea		G.DialogAlertStorage			move.l	#-1,-(sp)			_GetNewDialog					pea		G.DialogAlertStorage			move.w	#6,-(sp)			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			move.l	ItemHandle(a6),-(sp)			PEA		BUFFER(A6)			_SetItext			pea		G.DialogAlertStorage			move.w	#1,-(sp)			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			pea		G.DialogAlertStorage			_SetPort					move.w	#3,-(sp)			move.w	#3,-(sp)			_PenSize					pea		itemRect(a6)			move.w	#-4,-(sp)			move.w	#-4,-(sp)			_InsetRect					pea		itemRect(a6)			move.w	#16,-(sp)			move.w	#16,-(sp)			_FrameRoundRect		ModalErreurDisque			clr.l	-(sp)			pea		TheItemHitalert(a6)			_ModalDialog					move.w	TheItemHitalert(a6),d0			cmp.w	#2,d0			beq.s	OnContinuQuandMeme			cmp.w	#1,d0			bne.s	ModalErreurDisque			pea		G.DialogAlertStorage			_CloseDialog						move.l	#-1,d1			bra.s	Exit			OnContinuQuandMemeOnContinuOk			pea		G.DialogAlertStorage			_CloseDialogexit2						moveq	#0,d1			bra		exit			Exit					UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.new		TraitementErreurFichier		; this name will appear in the debugger			align 4				endp			* ================================================* PROCEDURE		ExportFichier()* ================================================		SEG	'Main'			; case sensitiveExportFichier	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkDialogStorage	ds	dWindLenreply		ds		StandardFileReplyfssSafeSave	ds.b	70	; fssRecordfsOpenErr	ds.w	1fsRefNum	ds.w	1seconds		ds.l	1Buffer		ds.l	1count		ds.l	1FileLenth	ds.l	1txtbuffer		ds.b	256itemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RectItemchoisi		ds.w	1paramBlock		ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierparamBlockBak	ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierLocalSize	EQU 	*			; size of all the local variables		endr				WITH	StackFrame,Reply,fssSpec		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		IMPORT	WaitTicks,CopySTR,AppendSTr,TraitementErreurFichier; on ouvre le dialog n°139 pour connaitre les choix des utilisateurs; fonction de fichier 		clr.l	-(sp) ; file filter = none		Move.w	#-1,-(sp); on veut tous les TYPEs de fichiers		clr.l	-(sp)		Pea		reply(a6)		string Pascal				pea		#'Sauvegarder l image ROM :'		pea		G.CurrentFileName		Pea		reply(a6)		_StandardPutFile		move.b	sfGood(a6),d0		beq		Exit2	; l'utilisateur à Cancelé; on regarde si le fichier existe déja ; on recopie le nouveau nom				lea		G.CurrentFileName,a1		lea		sfsname(a6),a0		bsr		CopyStr				tst.b	sfReplacing(a6)  		bne		FileExistAlready; le fichier n'existe pas	; on commence par créer le fichier en question.		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.l	sfsparID(a6),ioDirID(a0)		_HCreate		; maintenant le fichier éxiste FileExistAlready; on ouvre le fichier		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.b	#4,ioPermssn(a0)			;fsRWrShPerm			clr.l	ioOwnBuf(a0)		move.l	sfsparID(a6),ioDirID(a0)		_HOpen		jsr		TraitementErreurFichier			tst.l	d1		bne		Exit2							lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		clr.w	28(a0)	;DirIndex		clr.l	ioOwnBuf(a0)		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		_HGetFileInfo		jsr		TraitementErreurFichier		; écriture de l'image rom  vers le disque; ---------------------------------------------------------------------				lea		paramBlock(a6),a0		move.l	#8193,ioReqCount(a0)		move.l	buffer(a6),a1		move.l	G.RomImage,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)						_Write; ---------------------------------------------------------------------		; on a fini de d'écrire dans le fichier, on actualise les info du film; on commence par lire les infos: 	; il faut maintenant créer les infos pour le finder		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		move.l	Time,ioFlMdDat(a0)		lea		sfsname(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		Move.l	#' bin',ioFlUsrWds(a0)		move.l	#'Bbo1',4+ioFlUsrWds(a0)		move.l	sfsparID(a6),ioDirID(a0)		_HSetFileInfo		jsr		TraitementErreurFichier		; on dit au dos de s'assurer que tous à bien été écrit sur le disque				clr.l	-(sp)		move.w	#140,-(sp)		pea		DialogStorage(a6)		move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_FlushFile		jsr		TraitementErreurFichier		move.l	#60,-(sp)		bsr		WaitTicks		PEA		DialogStorage(a6)		_CloseDialog		closeFile			lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_CloseExit2			*   --------------------------------------------------------------------Exit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		align 4		DbgInfo.New	ExportFichier		; this name will appear in the debugger		ENDP************************************************	*	AppendStr(source str; a0, dest str; a1) **		SEG	'Main'AppendStr			PROC	EXPORT		movem.l	d0/a2-a3,-(sp)		move.l	A0,a2		move.l	A1,a3		move.b	(a1)+,d0		and.l	#$ff,d0		add.l	d0,a1								move.b	(a0),d0		and.l	#$ff,d0		add.l	#1,a0				_BlockMove				move.b	(a3),d0		add.b	(a2),d0		move.b	d0,(a3)		movem.l	(sp)+,d0/a2-a3		rts				DbgInfo.New		AppendStr		align 4			ENDP		************************************************	*	CopyStr(source str; a0, dest str; a1) **		CopyStr			PROC	EXPORT		movem.l	d0,-(sp)		move.b	(a0),d0		addq.b	#1,d0		and.l	#$ff,d0		_BlockMove		movem.l	(sp)+,d0		rts		DbgInfo.New		CopyStr		align 4			ENDP									END				; end of this source file