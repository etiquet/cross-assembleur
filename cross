* ==============================================* assembleur pour microprocesseur 6305* ==============================================* variables :CrossAssemble	proc exportProgramCounter	ds.w	1MPU			ds.l	1Flag			ds.w	1buffer			ds.b	256FileBuffer		ds.l	1	; adresse du buffer fichierFileEnd		ds.l	1RamStart		ds.l	1	; adresse de la ram pour assemblerZone			ds.l	1	; type de zone lue (étiquette, mnémonique…)currentline	ds.l	1	; n° de la ligne couranteerrorZone		ds.l	1	; pointeur de la zone d'erreuretiquetZone		ds.l	1	; pointeur de la zone d'étiquette				endR		move.l	filebuffer(a6),a0		move.l	#’6305’,mpu(a6)		move.l	#’ETIQ’,zone(a6)		clr.w		flag(a6)* Ouverture et Lecture du fichier source assembleur* passage ‘PASS1’ lecture du fichier et fabrication de la liste d’étiquettePASS1		move.l	filebuffer(a6),a4		PASS1_Loop		move.l	#’ETIQ’,zone(a6)		move.b	(a4)+,d0; on regarde si nous sommes sur une étiquette		cmp.b		#’;’,d0		beq		FinLigne_Passe1_Loop		; commentaire donc voir fin de ligne			cmp.b		#’*’,d0		beq		FinLigne_Passe1_Loop	; on regarde si nous lisons actuellement une étiquette		cmp.b		#’A’,d0		blo		PasEtiquette				cmp.b		#’z’,d0		bhi		PasEtiquette; nous sommes sur une étiquette on place le texte dans un buffer tampon		lea.l		buffer(a6),a0			moveq		#0,d7					RecopieEtiquette_Loop		move.b		-1(a4,d7),d0		cmp.b		#$21,d0			; si char < espace => plus de caractères utiles		blo.s		FinLigne		; nous sommes à la fin de la ligne/texte		move.b		d0,1(a0,d7.w)		addq.w		#1,d7		cmp.w		#255,d7		blo.s		RecopieEtiquette_LoopFinLigne		move.b		d7,(a0)		and.l		#$ffff,d7		; extension word => longWord		add.l		d7,a4			; a4 pointe sur le prochain caractère ; après l’étiquette	; on regarde si cette étiquette éxiste déja dans la liste		lea			buffer(a6),a0		bsr			GetEtiquetteValue		tst.l		d1		bne.s		NouvelleEtiquette		; oui elle existe donc erreur		lea			Buffer(a6),a0		move.l		currentline(a6),d0		move.l		#-10,d1					; duplicate label "label" in line ##		bsr			ErrorInListing				bra			ZoneMnemonic_Pass1				; elle n'existe pas, on en créer une autreNouvelleEtiquette		lea			Buffer(a6),a0		moveq		#0,d0				; 0 par défaut		move.l		#-1,d1				; pas de valeur attribuée		bsr			AddEtiquette		; nouvelle étiquette; on change de zone		ZoneMnemonic_Pass1		move.l	#’MNEM’,zone(a6)		; zone mnémonique				bsr		WaitChar				; on attend la prochaine lettre		;	on regarde si c'est une directive, si oui on regarde si l'on peut l'exécuter		move.l	a4,a0					; pointeur de la ligne		bsr		DoDirective		cmp.l	#-100,d1				; pas une directive erreur		beq.s	NotADirective					cmp.l	#-101					; directive "end" fin de fichier		beq		FinPass1				; on passe à la passe 2		cmp.l	#0,d1					; autre erreur		beq		FinLigne_Passe1				move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1		; pas d'erreur			FinLigne_Passe1_Loop; on attend la fin de la ligne		move.b	(a4)+,d0		cmp.b	#0,d0		beq.s	Start_Passe2			; 0 pour fin de fichier ( pas de end)		cmp.l	finTexte(a6),a4		bhi.s	Start_Passe2			; fin du fichier (pas de end)		cmp.b	#$1f,d0		bhi.s	FinLigne_Passe1_Loop		add.l	currentline(a6)			; nouvelle ligne		bra		PASS1_Loop				; on reboucle; -------------------------------------------------------------------; PASSE 2; génération du codeStart_Passe2		move.l	filebuffer(a6),a4		clr.l	programCounter(a6)		; on part au début		moveq.l	#1,currentline(a6)				PASS2_Loop		move.l	#’ETIQ’,zone(a6)		move.b	(a4)+,d0; on regarde si nous sommes sur une étiquette		cmp.b		#’;’,d0		beq		Fin_ligne_Passe2				cmp.b		#’*’,d0		beq		Fin_ligne_Passe2; on regarde si nous lisons actuellement une étiquette		cmp.b		#’A’,d0		blo		PasEtiquette				cmp.b		#’z’,d0		bhi		PasEtiquette; nous sommes sur une étiquette on place le texte dans un buffer tampon		lea.l		buffer(a6),a0			moveq		#0,d7					RecopieEtiquette_Loop_Passe2		move.b		-1(a4,d7),d0		cmp.b		#$21,d0			; si char < espace => plus de caractères utiles		blo.s		FinLigne_passe2		; nous sommes à la fin de la ligne/texte		move.b		d0,1(a0,d7.w)		addq.w		#1,d7		cmp.w		#255,d7		blo.s		RecopieEtiquette_Loop_passe2FinLigne_Passe2	; et de l'étiquette		move.b		d7,(a0)		and.l		#$ffff,d7		; extension word => longWord		add.l		d7,a4			; a4 pointe sur le prochain caractère ; après l’étiquette; on affecte la valeur du PC dans l'étiquette			move.l		ProgramCounter(a6),d0		lea			Buffer(a6),a0		bsr			SetEtiquetteValue		cmp.l		#1,d1		beq.s		ValueIsTheSame_Passe2				tst.l		d1		beq.s		PasErreurEtiquette_Passe2		move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1	PasErreurEtiquette_Passe2; on vient de changer la valeur de l'étiquette donc in faut repartir au début de la passe 2		; sauf s'il y a des erreurs		tst.l		errors(a6)		bne.s		ValueIsTheSame_Passe2		; une bonne méthode ??????????				bra			Start_Passe2; ------; la valeur de l'étiquette	est inchangée donc on continue d'assembler le programmeValueIsTheSame_Passe2		bsr			WaitNextChar		move.l		a4,a0		bsr			DoDirective; erreur dans d1		cmp.l		#-100,d1				; pas une directive erreur		beq.s		NotADirective_Passe2					cmp.l		#-101					; directive "end" fin de fichier		beq			FinPass2				; on a fini l'assemblage		cmp.l		#0,d1					; pas		beq.s		DirectiveOK_Passe2; autre erreur				move.l		currentline(a6),d0	; "error type label" in line ##		bsr			ErrorInListing		; error code in d1		bra			FinLigne_Passe2; -; l'éxécution de la directive est correcte donc on incrément le pcDirectiveOK_Passe2		add.l		ProgramCounter(a6),d0		move.l		d0,ProgramCounter(a6)		bra			FinLigne_Passe2;	NotADirective_Passe2		; ce n'est pas une directive donc c'est un assemblage 		move.l		a4,a0		bsr			DoAssemble		tst.l		d1		beq.s		PasErreurAssemblage_Pass2; erreur dans assemblage		move.l		currentline(a6),d0	;  "error name" in line ##		bsr			ErrorInListing		;  error code in d1; on continue poue les autres erreurs dans l'assemblage				PasErreurAssemblage_Pass2; longueur de l'instruction dans d0				add.l		ProgramCounter(a6),d0		move.l		d0,ProgramCounter(a6); pas d'erreur			FinLigne_Passe2_Loop; on attend la fin de la ligne		move.b	(a4)+,d0		cmp.b	#0,d0		beq.s	FinPasse2				; 0 pour fin de fichier ( pas de end)		cmp.l	finTexte(a6),a4		bhi.s	FinPasse2				; fin du fichier (pas de end)		cmp.b	#$1f,d0		bhi.s	FinLigne_Passe2_Loop		add.l	currentline(a6)			; nouvelle ligne		bra		PASS2_Loop				; on reboucle; --------------------------------------------------------; nous avons fini d'assembler le programmeFinPasse2; on regarde s'il y a des erreurs dans le fichier		tst.l	errors		beq		NoError		; on ouvre une fenètre pour sortir les erreurs				NoError										